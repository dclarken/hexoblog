<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于Hexo和Github的博客搭建]]></title>
    <url>%2Fhexoblog%2F2017%2F10%2F19%2F%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGithub%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建原理github pages github是项目托管网站，列出了项目的源文件，github有一个pages功能，可以自定义主页，用来代替默认的列出源列表的这个页面。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。对于个人博客的主页页面内容可以位于 master 下。user pages只有一个, project pages可以有多个, 对于个人博客而言, 两种方式都可以.如果用户申请了自己的域名, 还可以使用CNAME文件自定义domain name,这样访问你的域名就自动访问到github上的页面. 用户也可以自定义404页面.HexoHexo是一个快速、简洁并且高效的博客框架。Hexo使用Markdown解析文章，还可以使用期主题生成静态网页 搭建步骤大概可以分为以下几个步骤： 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 配置Hexo 怎样将Hexo与github page联系起来 怎样发布文章 主题 推荐 主题Next的配置 添加404 公益页面 环境准备配置Node.js安装环境：JavaScript工具，前端架构，编写出可扩展性高的服务器 安装Online documentation shortcuts模块 新打开的窗口中输入cmd，敲击回车，打开命令行界面 查看安装的是否成功1node -v npm -v 配置Git环境:Git工具可以在windows系统中的任意文件下进入命令行界面，可以建立Hexo和Github的连接 安装Online documentation shortcuts模块 查看安装是否成功1git --version github账号的配置 新建一个repository，命名为hexoblog 在settings页面中的Github Pages中开启gh pages功能，记录网址可以用于后续配置安装Hexo 新建一个目录并且创建Hexo文件夹，用于安装Hexo，并在命令行的窗口进入到该目录 命令行输入:安装hexo以及查看是否安装123npm install hexo-cli -gnpm install hexo --savehexo -v Hexo的体验 初始化 1hexo init 安装npm组件 1npm install 生成 1hexo g 开启端口 1hexo s 提示，在浏览器中输入以后网址既可以访问hexo界面1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 将hexo和github相连配置Git个人信息 设置Git的user.name和user.email 12git config --global user.name "Lander"git config --global user.email "dclarken@163.com" 生成秘钥，生成的秘钥要使用需要配置为github上的安全ssh秘钥Git ssh 配置使用 1ssh-keygen -t rsa -C "dclarken@163.com" 配置Deployment 在hexo安装目录下找到根配置文件_config.yml文件，找到Deployment句段1234deploy: type: git repo: repo: git@github.com:dclarken/hexoblog.git branch: master git插件安装 提前安装一个扩展1npm install hexo-deployer-git --save 主题配置以及文章发布Next主题配置使用 安装Next，利用Git工具将下载的主题文件拷贝在themes目录下 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题，切换主题一般可以用hexo clean来清空缓存 1theme: next 验证主题，生成端口，访问网址观察是否成功配置 1hexo s –debug 主题设定Next主题设定资料地址 添加文章，添加新的文章在source文件夹下的post文件中，文件名为引号中的字符1hexo new post "article title" 文件格式为markdown格式，初始生成的文件内容如下：123456---title: article titledate: 2017-8-12 11:31:21tags: [随笔,freinds]categories: [随笔]--- 添加标签页面，如果不添加该页面在主题config配置文件中，添加的tags会指向404界面12cd your-hexo-sitehexo new page tags 文件补充为以下格式：添加type字段，comments字段可以关闭评论1234title: 标签date: 2017-8-12 12:39:04type: "tags"comments: false 添加分类页面12cd your-hexo-sitehexo new page categories 文件补充以下格式：1234title: 分类date: 2017-8-12 12:39:04type: "categories"comments: false 搭建过程参考资料：参考文章地址致谢作者]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python语法]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F19%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[#基本语法#]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk+eclipse+python环境搭建]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F15%2Fjdk%2Beclipse%2Bpython%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[jdk下载：（java环境配置）jdk下载地址环境变量配置首先设置JAVA_HOME,点击新建，变量名：JAVA_HOME,变量值：D:\java\jdk1.7.0,即jdk安装的路径。设置CLASSPATH属性，变量名：CLASSPATH，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;此时需要注意的是最前有.;，不能忘记，%JAVA_HOME%代表D:\java\jdk1.7.0此路径。设置path属性，变量名：path，变量值：%java_home%\bin;%java_home%\jre\bin;，此属性一般都是有的，只需添加即可，注意分号的问题。在cmd中输入命令java检测安装是成功ps：%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;环境变量原本的文件内容表示的dos系统下cmd的解释器，在环境变量配置时，定义的环境变量文件名不区分大小写path=PATH。eclipse：eclipse下载地址选择的下载版本为一个zip而不是官网的exe文件，官网的文件还需要后续联网下载，网络不稳定容易失败，zip文件解压缩之后既可以使用。python插件：1.打开eclipse——Help——add-PyDev-http://pydev.org/updates——PyDev——PyDev for eclipse——下一步——重启——建立Python工程上述过程同样需要上境外网络，连接VPN实施。或者参考：2.python插件下载地址pyDev包下载地址下载PyDev 4.1.0.zip包，把压缩包里面的plugins中的文件解压到Eclipse安装目录下plugins文件夹中，压缩包里面features中的文件目录也是同样操作。之后重启Eclipse。检查是否已经正确安装pydev：打开Eclipse–&gt;Windows–&gt;preferences就能找到Pydev。配置解释器。官网下载Python27或者Python34选择Window &gt; Preferences &gt; Pydev &gt; Python Interpreter&gt;New ，继续配置解释器：Python安装在F:\Python27 路径下。单击 New，进入对话框。Interpreter Name可以随便命名，Interpreter Executable选择Python解释器python.exe，在安装文件夹下查找。而后下一步下一步。建立Python工程：工程建立：file-new-project-PyDev-PyDev Project-命名-finish文件建立：项目名右键-new-PyDev Module（.py文件）-编写-运行Python Run]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown编辑器]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F13%2FMarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[##MaHua是什么?一个在线编辑markdown文档的编辑器 向Mac下优秀的markdown编辑器mou致敬 ##MaHua有哪些功能？ 方便的导入导出功能 直接把一个markdown的文本文件拖放到当前这个页面就可以了 导出为一个html格式的文件，样式一点也不会丢失 编辑和预览同步滚动，所见即所得（右上角设置） VIM快捷键支持，方便vim党们快速的操作 （右上角设置） 强大的自定义CSS功能，方便定制自己的展示 有数量也有质量的主题,编辑器和预览区域 完美兼容Github的markdown语法 预览区域代码高亮 所有选项自动记忆 ##有问题反馈在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流 邮件(dev.hubo#gmail.com, 把#换成@) QQ: 287759234 weibo: @草依山 twitter: @ihubo ##捐助开发者在兴趣的驱动下,写一个免费的东西，有欣喜，也还有汗水，希望你喜欢我的作品，同时也能支持一下。当然，有钱捧个钱场（右上角的爱心标志，支持支付宝和PayPal捐助），没钱捧个人场，谢谢各位。 ##感激感谢以下的项目,排名不分先后 mou ace jquery ##关于作者 123def __init__(self): self.num=[] self.counts = [] #该文可以用来便于查看markdown的语法规则]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图dfs输出全排序]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F13%2F%E5%9B%BEdfs%E8%BE%93%E5%87%BA%E5%85%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[问题: 生成1~n的排列思路: 穷举所有可能 在生成结果数组前把重复的去掉探索到某一步发现原先选择达不到目标, 就退回一步重新选择.效率比普通DFS高. 可以优化排列数和素数环的程序两种代码一种没有加入回溯，一种有——-分隔 1234567891011121314#coding：utf-8A = [None for i in range(10)]N = 3def dfs(cur): if cur == N: print(A[:N]) else: for i in range(1, N+1): if i not in A[:cur]: A[cur] = i dfs(cur+1)dfs(0) 12345678910111213141516A = [None for i in range(0, 10)]V = [False for i in range(0, 10)]N = 4def dfs(cur): if cur == N: #边界条件到N的时候需要输出结果 print(A[:N]) else: for i in range(1, N+1): #遍历所有的情况 if not V[i]: #V为标志，到排序的这个位置上没有数据时候，进入下一步 V[i] = True #首先改变标志位为true，输入需要排入的数值 A[cur] = i dfs(cur+1) #继续往下搜索 V[i] = False #跳出了循环，需要回溯到进入循环之前的状态dfs(0) 问题: 数字1~n围成一个n个节点的环, 不允许数字重复, 任意2个相邻数字相加, 结果均为素数, 打印所有素数环的组合.思路: 同排列数, 多了素数判断. 123456789101112131415161718192021A = [None for i in range(0, 10)]N = 6def is_prime(n): for i in range(2, n//2+1): if n%i == 0: return False return Truedef dfs(cur): if cur == N: if is_prime(A[0]+A[N-1]): print(A[:N]) else: for i in range(1, N+1): if i not in A[:cur]: if cur == 0 or is_prime(i+A[cur-1]): A[cur] = i dfs(cur+1)dfs(0) 1234567891011121314151617181920212223A = [None for i in range(0, 10)]V = [False for i in range(0, 10)]N = 6def is_prime(n): for i in range(2, n//2+1): if n%i == 0: return False return Truedef dfs(cur): if cur == N: if is_prime(A[0]+A[N-1]): print(A[:N]) else: for i in range(1, N+1): if not V[i]: if cur == 0 or is_prime(i+A[cur-1]): V[i] = True A[cur] = i dfs(cur+1) V[i] = Falsedfs(0)]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图dfs水池个数问题]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F13%2F%E5%9B%BEdfs%E6%B0%B4%E6%B1%A0%E4%B8%AA%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[输入：第一行输入一个整数N，表示共有N组测试数据每一组数据都是先输入该地图的行数m(0&lt;m&lt;100)与列数n(0&lt;n&lt;100)，然后，输入接下来的m行每行输入n个数，表示此处有水还是没水（1表示此处是水池，0表示此处是地面）输出：输出该地图中水池的个数。要注意，每个水池的旁边（上下左右四个位置）如果还是水池的话的话，它们可以看做是同一个水池。 python代码，一直跑不出递归，已经醉了1234567891011121314151617181920212223242526272829#coding:utf-8import sys sys.setrecursionlimit(1000000000)def dfs(i,j): if (i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n or (s[i][j]==0)): return s[i][j]==0 dfs(i,j+1) dfs(i,j-1) dfs(i-1,j) dfs(i+1,j)if __name__ == '__main__': #N=raw_input().split() try: s=[] ans=0 m,n=[int(i) for i in raw_input().split()] for i in range(m): s.append([int(i) for i in raw_input().split()]) for i in range(m): for j in range(n): if s[i][j]==1: dfs(i,j) ans +=1 print(ans) print s except: pass 1234567891011121314151617181920212223242526272829303132333435363738394041424344 //C++代码： #include&lt;stdio.h&gt;#include&lt;string.h&gt;int s[101][101],n,m;void dfs(int i,int j)&#123; if(i&lt;0||i&gt;m||j&lt;0||j&gt;n||s[i][j]==0)//当所有的点为0时说明这是一个水池 return; s[i][j]=0;//每次搜索一个点后，置为0，避免重复 //从此点开始往四周扩展 dfs(i,j+1); dfs(i,j-1); dfs(i-1,j); dfs(i+1,j);&#125;int main()&#123; int N; scanf("%d",&amp;N); while(N--) &#123; int i,j,ans=0; memset(s,0,sizeof(s));//初始化，0表示地面，1表示水池 scanf("%d%d",&amp;m,&amp;n); for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) scanf("%d",&amp;s[i][j]); &#125; for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) &#123; if(s[i][j]==1)//每次从是水池的地方开始深搜 &#123; dfs(i,j); ans++; //搜索结束后既为满足条件 &#125; &#125; &#125; printf("%d\n",ans);//输出结果 &#125; return 0;&#125;]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图BFS最小转机问题]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F12%2F%E5%9B%BEBFS%E6%9C%80%E5%B0%8F%E8%BD%AC%E6%9C%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[思路：我们假设所有边的长度都是1，每一个线段表示一个转机，求最少转机就是求最短路径而已深度优先和广度优先的方法都可以，但是广度优先更适合所有边的权重一样的情况输入：第一行n,m,p,q分别为站点个数，航线个数，起始点，目的地后面m行表示m条航线输出：最小转机数量样例：5 7 1 51 21 32 32 43 43 54 5 2 123456789101112#coding:utf-8def change(n,line): #存储图的关系与标记数组 e=[[99999 for i in range(n+1)] for j in range(n+1)] #初始化所有的线路都为最大值99999 for i in range(1,n+1): e[i][i]=0 #自己和自己之间没有线路 for i in range(len(line)): #根据m行输入，确定哪一些节点之间是有航线的， a,b=line[i] a=int(a) b=int(b) e[a][b]=1 #节点之间有航班即为往返都可通行，即为双向图 e[b][a]=1 return e 12345678910111213141516171819def bfs(n,m,p,q,e): head=1 tail=1 que=[[0,0] for i in range(m)] que[tail]=[p,0] tail +=1 book=[0 for i in range(m)] book.insert(p,1) while head&lt;=tail: print ('que=',que) cur=que[head][0] #que队列中首航班号 for i in range(1,n+1): if e[cur][i]==1 and book[i]==0: #利用方向图，从城市cur到城市i是否有航班并且判断城市i是否在队列中 que[tail]=[i,que[head][1]+1] #满足条件，cur到城市i有航班并且城市i不在队列中，则i入队，转机次数+1 tail +=1 book[i]=1 #改变标记，以防重用 if tail==q+1: return(que[tail-1][1]) #由于tail是指向队列队尾的下一个位置，所以减1 head +=1 12345678910111213def main(): n,m,p,q=[int(i) for i in raw_input().split()] line=[] for i in range(int(m)): line.append(raw_input().split()) e=[] print (line) e=change(n,line) print(e) ans=bfs(n,m,p,q,e) print(ans)main()]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法集合]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F12%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[冒泡算法：比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。可以利用冒泡算法的案例：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。遇到偶数在前奇数在后的情况交换两者的位置。123456789#coding:utf-8def bubble(num,n): for i in range(n): for j in range(n-i-1): if num[j]&gt;num[j+1]: tmp=num[j] num[j]=num[j+1] num[j+1]=tmp return (num) 选择算法：每次讲min置成无序组起始位置元素下标例遍无序组找到最小的如果最小元素不是无序组起始位置元素，则与起始元素交换位置1234567891011def selectsort(num,n): for i in range(n): min=i for j in range(i,n): if num[j]&lt;num[min]: min=j if min!=i: tmp=num[i] num[i]=num[min] num[min]=tmp return (num) 插入算法：插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。123456789def insertsort(num,n): for i in range(1,n): tmp=num[i] j=i-1 while j&gt;0 and tmp&lt;num[j]: num[j+1]=num[j] j -=1 num[j+1]=tmp return (num) 快速排序：基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。12345678910111213141516def quicksort(L, low, high): i = low j = high if i &gt;= j: return L key = L[i] while i &lt; j: while i &lt; j and L[j] &gt;= key: j = j-1 L[i] = L[j] while i &lt; j and L[i] &lt;= key: i = i+1 L[j] = L[i] L[i] = key quicksort(L, low, i-1) quicksort(L, j+1, high) 123456def main(): num=[9,8,7,6,5,4,3,2,1,0] print(bubble(num,10)) print(selectsort(num,10)) print(insertsort(num,10))main()]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[article title]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F12%2Farticle-title%2F</url>
    <content type="text"><![CDATA[Welcome to dclarken’s page!8.12 is my first day for writing!First of all,I want to say thank you to my best friends :Dachang,Hongwei,Jingchang,Xidun,Yue,YunhaoBest wishes to all of you!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>freinds</tag>
      </tags>
  </entry>
</search>
