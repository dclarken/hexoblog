<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于Hexo和Github的博客搭建]]></title>
    <url>%2Fhexoblog%2F2017%2F10%2F19%2F%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGithub%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[搭建原理github pages github是项目托管网站，列出了项目的源文件，github有一个pages功能，可以自定义主页，用来代替默认的列出源列表的这个页面。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。对于个人博客的主页页面内容可以位于 master 下。user pages只有一个, project pages可以有多个, 对于个人博客而言, 两种方式都可以.如果用户申请了自己的域名, 还可以使用CNAME文件自定义domain name,这样访问你的域名就自动访问到github上的页面. 用户也可以自定义404页面.HexoHexo是一个快速、简洁并且高效的博客框架。Hexo使用Markdown解析文章，还可以使用期主题生成静态网页 搭建步骤大概可以分为以下几个步骤： 搭建环境准备（包括node.js和git环境，gitHub账户的配置） 安装Hexo 配置Hexo 怎样将Hexo与github page联系起来 怎样发布文章 主题 推荐 主题Next的配置 添加404 公益页面 环境准备配置Node.js安装环境：JavaScript工具，前端架构，编写出可扩展性高的服务器 安装Online documentation shortcuts模块 新打开的窗口中输入cmd，敲击回车，打开命令行界面 查看安装的是否成功1node -v npm -v 配置Git环境:Git工具可以在windows系统中的任意文件下进入命令行界面，可以建立Hexo和Github的连接 安装Online documentation shortcuts模块 查看安装是否成功1git --version github账号的配置 新建一个repository，命名为hexoblog 在settings页面中的Github Pages中开启gh pages功能，记录网址可以用于后续配置安装Hexo 新建一个目录并且创建Hexo文件夹，用于安装Hexo，并在命令行的窗口进入到该目录 命令行输入:安装hexo以及查看是否安装123npm install hexo-cli -gnpm install hexo --savehexo -v Hexo的体验 初始化 1hexo init 安装npm组件 1npm install 生成 1hexo g 开启端口 1hexo s 提示，在浏览器中输入以后网址既可以访问hexo界面1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 将hexo和github相连配置Git个人信息 设置Git的user.name和user.email 12git config --global user.name "Lander"git config --global user.email "dclarken@163.com" 生成秘钥，生成的秘钥要使用需要配置为github上的安全ssh秘钥Git ssh 配置使用 1ssh-keygen -t rsa -C "dclarken@163.com" 配置Deployment 在hexo安装目录下找到根配置文件_config.yml文件，找到Deployment句段1234deploy: type: git repo: repo: git@github.com:dclarken/hexoblog.git branch: master git插件安装 提前安装一个扩展1npm install hexo-deployer-git --save 主题配置以及文章发布Next主题配置使用 安装Next，利用Git工具将下载的主题文件拷贝在themes目录下 12cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题，切换主题一般可以用hexo clean来清空缓存 1theme: next 验证主题，生成端口，访问网址观察是否成功配置 1hexo s –debug 主题设定Next主题设定资料地址 添加文章，添加新的文章在source文件夹下的post文件中，文件名为引号中的字符1hexo new post "article title" 文件格式为markdown格式，初始生成的文件内容如下：123456---title: article titledate: 2017-8-12 11:31:21tags: [随笔,freinds]categories: [随笔]--- 添加标签页面，如果不添加该页面在主题config配置文件中，添加的tags会指向404界面12cd your-hexo-sitehexo new page tags 文件补充为以下格式：添加type字段，comments字段可以关闭评论1234title: 标签date: 2017-8-12 12:39:04type: "tags"comments: false 添加分类页面12cd your-hexo-sitehexo new page categories 文件补充以下格式：1234title: 分类date: 2017-8-12 12:39:04type: "categories"comments: false 搭建过程参考资料：参考文章地址致谢作者]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BGP的工作原理]]></title>
    <url>%2Fhexoblog%2F2017%2F09%2F12%2FBGP%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[在我们使用AWS提供的硬件VPN服务时，可以使用静态和动态的方式构建隧道。静态的是指事先知道对方的公网IP，在两个IP之间写好静态的路由，构建一条加密的隧道动态是指使用BGP协议来自动学习路由。 BGP(Border Gateway Protocol)边界网关协议，TCP 179BGP是一种在自治系统（AS）之间动态交换路由信息的路由协议。一个自治系统的经典定义是在一个管理机构控制之下的一组路由器，它使用IGP和普通度量值向其他自治系统转发报文。在BGP中使用自治系统这个术语是为了强调这样一个事实：一个自治系统的管理对于其他自治系统而言是提供一个统一的内部选路计划，它为那些通过它可以到达的网络提供了一个一致的描述。BGP,边界网关协议，是自主网络系统中网关之间交换器路由信息的协议。边界网关协议常常应用于互联网的网关之间。路由表包含已知路由器的列表、路由器能够达到的地址以及到达每个路由器的路径的跳数。BGP报文的四种类型： 报文Open：打招呼“你好，跟我交个朋友吧！” KeepAlive：我还活着呢，别不理我 Update：有新闻…… Notification：我不跟你玩了! BGP协议中消息的应用通过TCP建立BGP连接时，发送open消息连接建立后，如果有路由需要发送或路由变化时，发送UPDATE消息通告对端路由信息稳定后此时要定时发送KEEPALIVE消息（60s）以保持BGP连接的有效性当本地BGP在运行中发现错误时，要发送NOTIFICATION消息通告BGP对端 BGP择路的13个规则 忽略下一跳不可达的路由 忽略不同步的IBGP路由 首选具有最大权重优先，思科私有。(local to router) 首选具有最大本地优先级优先。(global within AS) 首选具有始发本地的路由的路由器优先，(next hop=0.0.0.0) 首选具有最短AS-PATH的路由。 首选具有最小的源码的路由，IGP〈EBP〈incomplete 当所有路由的AS号都相同的时候，首选MED最低的路由，在所有AS号码相同的时候比较MED 首选具有EBGP〉联盟EBGP&gt;IBGP 首选具有最近的IGP邻居路由器优先，metric 首选具有最老的路由优先（注意：现在这条基本不用） 首选具有最低ROUTER-ID的路由。(2个BGP地址不能建邻) 首选具有最低的neighbor的IP地址]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>网络协议</tag>
        <tag>bgp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python语法]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F19%2FPython%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[#基本语法#]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk+eclipse+python环境搭建]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F15%2Fjdk%2Beclipse%2Bpython%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[jdk下载：（java环境配置）jdk下载地址环境变量配置首先设置JAVA_HOME,点击新建，变量名：JAVA_HOME,变量值：D:\java\jdk1.7.0,即jdk安装的路径。设置CLASSPATH属性，变量名：CLASSPATH，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;此时需要注意的是最前有.;，不能忘记，%JAVA_HOME%代表D:\java\jdk1.7.0此路径。设置path属性，变量名：path，变量值：%java_home%\bin;%java_home%\jre\bin;，此属性一般都是有的，只需添加即可，注意分号的问题。在cmd中输入命令java检测安装是成功ps：%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;环境变量原本的文件内容表示的dos系统下cmd的解释器，在环境变量配置时，定义的环境变量文件名不区分大小写path=PATH。eclipse：eclipse下载地址选择的下载版本为一个zip而不是官网的exe文件，官网的文件还需要后续联网下载，网络不稳定容易失败，zip文件解压缩之后既可以使用。python插件：1.打开eclipse——Help——add-PyDev-http://pydev.org/updates——PyDev——PyDev for eclipse——下一步——重启——建立Python工程上述过程同样需要上境外网络，连接VPN实施。或者参考：2.python插件下载地址pyDev包下载地址下载PyDev 4.1.0.zip包，把压缩包里面的plugins中的文件解压到Eclipse安装目录下plugins文件夹中，压缩包里面features中的文件目录也是同样操作。之后重启Eclipse。检查是否已经正确安装pydev：打开Eclipse–&gt;Windows–&gt;preferences就能找到Pydev。配置解释器。官网下载Python27或者Python34选择Window &gt; Preferences &gt; Pydev &gt; Python Interpreter&gt;New ，继续配置解释器：Python安装在F:\Python27 路径下。单击 New，进入对话框。Interpreter Name可以随便命名，Interpreter Executable选择Python解释器python.exe，在安装文件夹下查找。而后下一步下一步。建立Python工程：工程建立：file-new-project-PyDev-PyDev Project-命名-finish文件建立：项目名右键-new-PyDev Module（.py文件）-编写-运行Python Run]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown编辑器]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F13%2FMarkdown%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[##MaHua是什么?一个在线编辑markdown文档的编辑器 向Mac下优秀的markdown编辑器mou致敬 ##MaHua有哪些功能？ 方便的导入导出功能 直接把一个markdown的文本文件拖放到当前这个页面就可以了 导出为一个html格式的文件，样式一点也不会丢失 编辑和预览同步滚动，所见即所得（右上角设置） VIM快捷键支持，方便vim党们快速的操作 （右上角设置） 强大的自定义CSS功能，方便定制自己的展示 有数量也有质量的主题,编辑器和预览区域 完美兼容Github的markdown语法 预览区域代码高亮 所有选项自动记忆 ##有问题反馈在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流 邮件(dev.hubo#gmail.com, 把#换成@) QQ: 287759234 weibo: @草依山 twitter: @ihubo ##捐助开发者在兴趣的驱动下,写一个免费的东西，有欣喜，也还有汗水，希望你喜欢我的作品，同时也能支持一下。当然，有钱捧个钱场（右上角的爱心标志，支持支付宝和PayPal捐助），没钱捧个人场，谢谢各位。 ##感激感谢以下的项目,排名不分先后 mou ace jquery ##关于作者 123def __init__(self): self.num=[] self.counts = [] #该文可以用来便于查看markdown的语法规则]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图dfs输出全排序]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F13%2F%E5%9B%BEdfs%E8%BE%93%E5%87%BA%E5%85%A8%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[问题: 生成1~n的排列思路: 穷举所有可能 在生成结果数组前把重复的去掉探索到某一步发现原先选择达不到目标, 就退回一步重新选择.效率比普通DFS高. 可以优化排列数和素数环的程序两种代码一种没有加入回溯，一种有——-分隔 1234567891011121314#coding：utf-8A = [None for i in range(10)]N = 3def dfs(cur): if cur == N: print(A[:N]) else: for i in range(1, N+1): if i not in A[:cur]: A[cur] = i dfs(cur+1)dfs(0) 12345678910111213141516A = [None for i in range(0, 10)]V = [False for i in range(0, 10)]N = 4def dfs(cur): if cur == N: #边界条件到N的时候需要输出结果 print(A[:N]) else: for i in range(1, N+1): #遍历所有的情况 if not V[i]: #V为标志，到排序的这个位置上没有数据时候，进入下一步 V[i] = True #首先改变标志位为true，输入需要排入的数值 A[cur] = i dfs(cur+1) #继续往下搜索 V[i] = False #跳出了循环，需要回溯到进入循环之前的状态dfs(0) 问题: 数字1~n围成一个n个节点的环, 不允许数字重复, 任意2个相邻数字相加, 结果均为素数, 打印所有素数环的组合.思路: 同排列数, 多了素数判断. 123456789101112131415161718192021A = [None for i in range(0, 10)]N = 6def is_prime(n): for i in range(2, n//2+1): if n%i == 0: return False return Truedef dfs(cur): if cur == N: if is_prime(A[0]+A[N-1]): print(A[:N]) else: for i in range(1, N+1): if i not in A[:cur]: if cur == 0 or is_prime(i+A[cur-1]): A[cur] = i dfs(cur+1)dfs(0) 1234567891011121314151617181920212223A = [None for i in range(0, 10)]V = [False for i in range(0, 10)]N = 6def is_prime(n): for i in range(2, n//2+1): if n%i == 0: return False return Truedef dfs(cur): if cur == N: if is_prime(A[0]+A[N-1]): print(A[:N]) else: for i in range(1, N+1): if not V[i]: if cur == 0 or is_prime(i+A[cur-1]): V[i] = True A[cur] = i dfs(cur+1) V[i] = Falsedfs(0)]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图dfs水池个数问题]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F13%2F%E5%9B%BEdfs%E6%B0%B4%E6%B1%A0%E4%B8%AA%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[输入：第一行输入一个整数N，表示共有N组测试数据每一组数据都是先输入该地图的行数m(0&lt;m&lt;100)与列数n(0&lt;n&lt;100)，然后，输入接下来的m行每行输入n个数，表示此处有水还是没水（1表示此处是水池，0表示此处是地面）输出：输出该地图中水池的个数。要注意，每个水池的旁边（上下左右四个位置）如果还是水池的话的话，它们可以看做是同一个水池。 python代码，一直跑不出递归，已经醉了1234567891011121314151617181920212223242526272829#coding:utf-8import sys sys.setrecursionlimit(1000000000)def dfs(i,j): if (i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n or (s[i][j]==0)): return s[i][j]==0 dfs(i,j+1) dfs(i,j-1) dfs(i-1,j) dfs(i+1,j)if __name__ == '__main__': #N=raw_input().split() try: s=[] ans=0 m,n=[int(i) for i in raw_input().split()] for i in range(m): s.append([int(i) for i in raw_input().split()]) for i in range(m): for j in range(n): if s[i][j]==1: dfs(i,j) ans +=1 print(ans) print s except: pass 1234567891011121314151617181920212223242526272829303132333435363738394041424344 //C++代码： #include&lt;stdio.h&gt;#include&lt;string.h&gt;int s[101][101],n,m;void dfs(int i,int j)&#123; if(i&lt;0||i&gt;m||j&lt;0||j&gt;n||s[i][j]==0)//当所有的点为0时说明这是一个水池 return; s[i][j]=0;//每次搜索一个点后，置为0，避免重复 //从此点开始往四周扩展 dfs(i,j+1); dfs(i,j-1); dfs(i-1,j); dfs(i+1,j);&#125;int main()&#123; int N; scanf("%d",&amp;N); while(N--) &#123; int i,j,ans=0; memset(s,0,sizeof(s));//初始化，0表示地面，1表示水池 scanf("%d%d",&amp;m,&amp;n); for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) scanf("%d",&amp;s[i][j]); &#125; for(i=0;i&lt;m;i++) &#123; for(j=0;j&lt;n;j++) &#123; if(s[i][j]==1)//每次从是水池的地方开始深搜 &#123; dfs(i,j); ans++; //搜索结束后既为满足条件 &#125; &#125; &#125; printf("%d\n",ans);//输出结果 &#125; return 0;&#125;]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图BFS最小转机问题]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F12%2F%E5%9B%BEBFS%E6%9C%80%E5%B0%8F%E8%BD%AC%E6%9C%BA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[思路：我们假设所有边的长度都是1，每一个线段表示一个转机，求最少转机就是求最短路径而已深度优先和广度优先的方法都可以，但是广度优先更适合所有边的权重一样的情况输入：第一行n,m,p,q分别为站点个数，航线个数，起始点，目的地后面m行表示m条航线输出：最小转机数量样例：5 7 1 51 21 32 32 43 43 54 5 2 123456789101112#coding:utf-8def change(n,line): #存储图的关系与标记数组 e=[[99999 for i in range(n+1)] for j in range(n+1)] #初始化所有的线路都为最大值99999 for i in range(1,n+1): e[i][i]=0 #自己和自己之间没有线路 for i in range(len(line)): #根据m行输入，确定哪一些节点之间是有航线的， a,b=line[i] a=int(a) b=int(b) e[a][b]=1 #节点之间有航班即为往返都可通行，即为双向图 e[b][a]=1 return e 12345678910111213141516171819def bfs(n,m,p,q,e): head=1 tail=1 que=[[0,0] for i in range(m)] que[tail]=[p,0] tail +=1 book=[0 for i in range(m)] book.insert(p,1) while head&lt;=tail: print ('que=',que) cur=que[head][0] #que队列中首航班号 for i in range(1,n+1): if e[cur][i]==1 and book[i]==0: #利用方向图，从城市cur到城市i是否有航班并且判断城市i是否在队列中 que[tail]=[i,que[head][1]+1] #满足条件，cur到城市i有航班并且城市i不在队列中，则i入队，转机次数+1 tail +=1 book[i]=1 #改变标记，以防重用 if tail==q+1: return(que[tail-1][1]) #由于tail是指向队列队尾的下一个位置，所以减1 head +=1 12345678910111213def main(): n,m,p,q=[int(i) for i in raw_input().split()] line=[] for i in range(int(m)): line.append(raw_input().split()) e=[] print (line) e=change(n,line) print(e) ans=bfs(n,m,p,q,e) print(ans)main()]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法集合]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F12%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[冒泡算法：比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。可以利用冒泡算法的案例：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。遇到偶数在前奇数在后的情况交换两者的位置。123456789#coding:utf-8def bubble(num,n): for i in range(n): for j in range(n-i-1): if num[j]&gt;num[j+1]: tmp=num[j] num[j]=num[j+1] num[j+1]=tmp return (num) 选择算法：每次讲min置成无序组起始位置元素下标例遍无序组找到最小的如果最小元素不是无序组起始位置元素，则与起始元素交换位置1234567891011def selectsort(num,n): for i in range(n): min=i for j in range(i,n): if num[j]&lt;num[min]: min=j if min!=i: tmp=num[i] num[i]=num[min] num[min]=tmp return (num) 插入算法：插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。当然，插入过程中涉及到了元素的移动。123456789def insertsort(num,n): for i in range(1,n): tmp=num[i] j=i-1 while j&gt;0 and tmp&lt;num[j]: num[j+1]=num[j] j -=1 num[j+1]=tmp return (num) 快速排序：基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。一趟快速排序的算法是： 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1； 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]； 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换； 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换； 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。12345678910111213141516def quicksort(L, low, high): i = low j = high if i &gt;= j: return L key = L[i] while i &lt; j: while i &lt; j and L[j] &gt;= key: j = j-1 L[i] = L[j] while i &lt; j and L[i] &lt;= key: i = i+1 L[j] = L[i] L[i] = key quicksort(L, low, i-1) quicksort(L, j+1, high) 123456def main(): num=[9,8,7,6,5,4,3,2,1,0] print(bubble(num,10)) print(selectsort(num,10)) print(insertsort(num,10))main()]]></content>
      <categories>
        <category>code</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[article title]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F12%2Farticle-title%2F</url>
    <content type="text"><![CDATA[Welcome to dclarken’s page!8.12 is my first day for writing!First of all,I want to say thank you to my best friends :Dachang,Hongwei,Jingchang,Xidun,Yue,YunhaoBest wishes to all of you!]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>freinds</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四七层模型协议比较]]></title>
    <url>%2Fhexoblog%2F2017%2F08%2F12%2F%E5%9B%9B%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%8D%8F%E8%AE%AE%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[OSI (Open System Interconnection)开放式系统互联参考模型。从下到上七层模型功能及其代表协议： 物理层(Physical) ：规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。Bit，比特。典型协议代表：EIA/TIA-232, EIA/TIA-499, V.35, V.24, RJ45, Ethernet, IEEE 802.3x(以太网) 物理层, FDDI(Fiber Distributed Data Interface, 光纤分布式数据接口) 物理层 数据链路层(Data Link) : 在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。Frame，帧。典型协议代表：SDLC(Synchronous DataLink Control，同步数据链路控制), HDLC(High-Level Data Link Control, 高级数据链路控制), PPP(Point-to-Point 点到点), IEEE 802.3x 数据链路层, FDDI 数据链路层, ATM(Asynchronous Transfer Mode, 异步传输模式), IEEE 802.5(令牌环) , Frame Relay(帧中继) 网络层(Network) : 负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。 Packet，包。典型协议代表：IP, ICMP, IGMP, IPX, BGP, OSPF, RIP, IGRP, EIGRP, ARP, RARP, X.25 传输层(Transport) : 传输层是第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 Segment，段。典型协议代表：TCP, UDP, TLS, RTP, SCTP, SPX, ATP, IL 会话层(Session) : 管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。典型协议代表：RPC, SQL, NFS, NetBIOS, SCP, ASP, SSH, Winsock, BSD sockets 表示层(Presentation) : 对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。典型协议代表：TIFF, GIF, JPEG, PICT, ASCII, EBCDIC, encryption, MPEG, MIDI, HTML 应用层(Application) : 为操作系统或网络应用程序提供访问网络服务的接口。典型协议代表：FTP, WWW, Telnet, NFS, SMTP, Gateway, SNMP, HTTP, Whois, SSHOSI 七层模型各层设备：物理层：各种传输媒体(光线，网线)，各类 DTE 和 DCE 之间通讯的物理设备(计算机， HUB)，各类插槽，插座数据链路层：两个子层：LLC(Logical Link Control, 逻辑链路控制层)，MAC(Media Access Control，媒体访问控制层)。网卡，网桥和二层交换机网路层：路由器，网关和三层交换机传输层：四层交换机会话层：五层交换机表示层：六层交换机应用层：计算机，负载均衡和七成交换机 TCP/IP网络协议TCP/IP(Transmission Control Protocol/Internet Protocol，传输控制协议/网间网协议)是目前世界上应用最为广泛的协议，它的流行与 Internet 的迅猛发展密切相关。TCP/IP 最初是为互联网的原型 ARPANET 所设计的，目的是提供一整套方便实用、能应用于多种网络上的协议，事实证明 TCP/IP 做到了这一点，它使网络互联变得容易起来，并且使越来越多的网络加入其中，成为 Internet 的事实标准。TCP/IP 参考模型分为四个层次： 主机到网络层:实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。 网络互连层：定义了分组格式和协议，即IP协议（Internet Protocol）。网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。 传输层：使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。 UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。 应用层：包括 OSI 参考模型中的会话层和表示层。面向不同的网络应用引入不同的应用层协议。其中，有基于 TCP 协议的，如 FTP(File Transfer Protocol，文件传输协议)， Telnet(虚拟终端协议)， HTTP(Hyper Text Transfer Protocol，超文本链接协议)；基于 UDP 协议的：如 SNMP, TFTP，NTP。 OSI七层协议和TCP/IP四层协议之比较: 分层结构OSI参考模型与TCP/IP协议都采用了分层结构，都是基于独立的协议栈的概念。OSI参考模型有7层，而TCP/IP协议只有 4 层，即 TCP/IP协议没有了表示层和会话层，并且把数据链路层和物理层合并为网络接口层。不过，二者的分层之间有一定的对应关系 标准的特色OSI 参考模型的标准最早是由 ISO 和 CCITT (ITU的前身)制定的，有浓厚的通信背景，因此也打上了深厚的通信系统的特色，比如对服务质量（QoS）、差错率的保证，只考虑了面向连接的服务。并且是先定义一套功能完整的构架，再根据该构架来发展相应的协议与系统。TCP/IP 协议产生于对 Internet 网络的研究与实践中，是应实际需求而产生的，再由 IAB、IETF 等组织标准化，而并不是之前定义一个严谨的框架。而且 TCP/IP 最早是在 UNIX 系统中实现的，考虑了计算机网络的特点，比较适合计算机实现和使用。 连接服务OSI 的网络层基本与 TCP/IP 的网际层对应，二者的功能基本相似，但是寻址方式有较大的区别。OSI的地址空间为不固定的可变长，由选定的地址命名方式决定，最长可达 160byte，可以容纳非常大的网络，因而具有较大的成长空间。根据 OSI 的规定，网络上每个系统至多可以有 256 个通信地址。TCP/IP网络的地址空间为固定的 4byte (在目前常用的 IPv4 中是这样，在 IPv6 中将扩展到 16byte)。网络上的每一个系统至少有一个唯一的地址与之对应。 传输服务OSI 与 TCP/IP 的传输层都对不同的业务采取不同的传输策略。OSI 定义了五个不同层次的服务：TP1，TP2，TP3，TP4，TP5。TCP/I P定义了 TCP 和 UDP 两种协议，分别具有面向连接和面向无连接的性质。其中 TCP 与 OSI 中的 TP4，UDP 与OSI中的 TP0 在构架和功能上大体相同，只是内部细节有一些差异。 应用范围OSI 由于体系比较复杂，而且设计先于实现，有许多设计过于理想，不太方便计算机软件实现，因而完全实现 OSI 参考模型的系统并不多，应用的范围有限。而 TCP/IP 协议最早在计算机系统中实现，在 UNIX、Windows平台中都有稳定的实现，并且提供了简单方便的编程接口 (API)，可以在其上开发出丰富的应用程序，因此得到了广泛的应用。TCP/IP 协议已成为目前网际互联事实上的国际标准和工业标准。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>tcp/ip</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
</search>
