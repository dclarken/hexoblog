<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ALB应用程序负载均衡</title>
    <url>/hexoblog/2017/10/01/ALB%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p><code>介绍：</code></p>
<p>应用程序负载均衡器Application Load Balancer是 Elastic Load Balancing 服务的一个负载均衡选项，在应用程序层运行，支持您在运行于一个或多个 Amazon Elastic Compute Cloud (Amazon EC2) 实例上的多个服务或容器之间基于内容定义路由规则。<br>负载均衡器收到请求后，会按照优先级顺序评估侦听器规则以确定应用哪个规则，然后使用轮询路由算法从目标组中选择一个目标以实施规则操作。可以配置侦听器规则，以根据应用程序流量的内容，将请求路由至不同的目标组。每个目标组的路由都是单独进行的，即使某个目标已在多个目标组中注册。<br>应用程序负载均衡器概述文档：<br><a href="http://docs.aws.amazon.com/zh_cn/elasticloadbalancing/latest/application/introduction.html">文档资料地址</a></p>
<p><code>组成部分：</code></p>
<ul>
<li>负载均衡器 充当客户端的单一接触点。可以向您的负载均衡器添加一个或多个侦听器。监听规则可以基于路径和基于主机的，例如，如果一个规则具有路径模式 &#x2F;img&#x2F;<em>，此规则会将 &#x2F;img&#x2F;picture.jpg 的请求转发给指定目标组，规则是具有主机模式</em>.example.com，此规则将*.example.com的请求转发给指定目标组。</li>
<li>侦听器 使用您配置的协议和端口检查来自客户端的连接请求，并根据您定义的规则将请求转发到一个或多个目标组。每个规则指定一个目标组、条件和优先级。满足条件时，流量会转发到目标组。您必须为每个侦听器定义一个默认规则，然后，您可以添加规则来根据请求内容指定不同目标组 (也称为基于内容的路由)。</li>
<li>每个目标组 使用您指定的协议和端口号将请求路由到一个或多个注册目标，例如 EC2 实例。您可以向多个目标组注册一个目标。您可以对每个目标组配置运行状况检查。在注册到目标组 (它是使用负载均衡器的侦听器规则指定的) 的所有目标上，执行运行状况检查。</li>
</ul>
<p><code>使用应用程序负载均衡器而不是传统负载均衡器具有以下优势：</code></p>
<ul>
<li>支持基于路径的路由。对于根据请求中的 URL 转发请求的侦听器，您可以为它配置规则。这让您可以将应用程序构造为较小的服务，并根据 URL 内容将请求路由到正确的服务。<br>通过使用多个端口注册实例，支持将请求路由到单个 EC2 实例上的多个服务。</li>
<li>支持容器化的应用程序。计划任务时，Amazon EC2 Container Service (Amazon ECS) 可以选择一个未使用的端口，并可以使用此端口向目标组注册该任务。这样可以高效地使用您的群集。</li>
<li>支持单独监控每个服务的运行状况，因为运行状况检查是在目标组级别定义的，并且许多 CloudWatch 指标是在目标组级别报告的。将目标组挂载到 Auto Scaling 组的功能使您能够根据需求动态扩展每个服务。<br>访问日志包含附加信息，并以压缩格式存储。已改进负载均衡器性能</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>AWS</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS简称及基本架构介绍</title>
    <url>/hexoblog/2017/08/12/AWS%E7%AE%80%E7%A7%B0%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/21/59ea9bac76764.png" alt="tu"><br><a href="https://aws.amazon.com/cn/documentation/">文档教程位置</a></p>
<p><code>AWS整体架构</code></p>
<p>·VPC：·<br>私有网络AWS 云中逻辑隔离的虚拟网络。从所选的范围内定义 VPC 的 IP 地址空间
	</p>
<ul>
<li>对VPC的IP寻CIDR块的控制</li>
<li>为您的VPC CIDR块划分子网的能力</li>
<li>网络访问控制列表</li>
<li>多个IP地址和多个弹性网络接口（ENI）的分配</li>
<li>通过私有连接将VPC和现场IT基础设施连接</li>
</ul>
<p>·常见的路由：·<br>路由表的将决定子网的功能
	</p>
<ul>
<li>IGW：提供对internet的访问，公有子网带通过IGW实现进&#x2F;出站internet连接</li>
<li>VGW：提供对数据中心的访问，虚拟专用网关</li>
<li>NAT 网关：一项高度可用的托管网络地址转换 (NAT) 服务，可便于私有子网中的资源访问 Internet，可以在官方AMI上直接启动NAT网关实例，私有子网通过公有子网中运行NAT的Amazon EC2实例实现的出战Internet连接。</li>
<li>VPC对等：与NACL和安全组一起维护VPC的安全，允许在对等VPC之间路由流量，这样两个VPC中的实例可以彼此通信，就像在同一个网络中一样。两个对等的VPC不能具有CIDR块重叠的CIDR块。</li>
</ul>
<p>·ELB：·<br>Elastic Load Balancing 弹性负载均衡，</p>
<ul>
<li>在多个 Amazon EC2 实例之间自动分配应用程序的传入流量，软件负载均衡。</li>
<li>在同一区域可用区实例之间实现均衡</li>
<li>根据用户定义的运行状况检查检测状况欠佳的实例</li>
<li>SSL终端支持自动一证书</li>
</ul>
<p>·EC2：·<br>Elastic Compute Cloud  一种 Web 服务，云计算服务平台，用于计算相当于一个虚拟机，可以在云中提供安全并且大小可调的计算容量。该服务旨在让开发人员能够更轻松地进行 Web 规模的云计算。让使用者可以租用云端电脑运行所需应用的系统。<br>类型：C3计算优化、R3内存优化、G2 GPU优化、I2  HS1存储优化</p>
<p><code>ENI：</code><br>弹性网络接口，创建的EC2实例具有的虚拟网络接口，具有属性如下：MAC地址、主要私有IP地址，一个或多个次要私有IP地址、每个私有IP地址都有弹性EIP、公有IP地址、安全组、目标检查标记、说明。使用案例：创建管理网络；许可身份验证；在VPC中使用网络和安全性设备</p>
<p><code>EIP：</code><br>专为动态云计算设计的静态IP地址，EIP与AWS账号关联，而不是与特定实例关联；而公有IP地址也称为动态IP地址与实例相关。</p>
<p><code>IGW：</code><br>整体网关</p>
<p><code>ALB：</code><br>Application Load Balancer ALB是位于OSI模型第七层的负载均衡器，因此它能根据网络包的内容将该网络包路由到不同的后端服务。现有的负载均衡器多是位于OSI模型第四层的TCP&#x2F;UDP均衡器。与这些均衡器不同的是，ALB将检查网络包的内容，并将该网络包发送给适当的服务。当前，ALB支持基于URL对路由流量定义多至十条的独立规则。</p>
<p><code>Amazon CloudWatch </code><br>是一项针对 AWS 云资源和在 AWS 上运行的应用程序进行监控的服务。CPU 使用率、数据传输和磁盘使用活动等，弹性负载均衡器、Amazon SQS 队列、Amazon SNS 主题等更多</p>
<p><code>Amazon CloudFront</code><br> 是一种全球内容分发网络 (CDN) 服务，用于内容传输，可以安全地以低延迟和高传输速度向浏览者分发数据、视频、应用程序和 API。建或修改现有 AWS CloudFormation 模板。一个描述了您的所有资源及其属性的模板。</p>
<p> <code>Amazon Simple Storage Service (Amazon S3)</code>对象存储，使您能够轻松实用地大规模收集、存储和分析数据，而不管格式如何。S3 是专为从任意位置存储和检索任意大小的数据而构建的对象存储，包括来自网站和移动应用程序、公司应用程序的数据以及来自 IoT 传感器或设备的数据。S3可与CloudFront(CDN)结合使用，可以利用分布式网络给边远地区加速
	</p>
<ul>
<li>一个对象的大小可以达到5TB</li>
<li>每个对象存储在存储桶中，通过开发人员分配的唯一密钥进行检索</li>
<li>无限的存储、无限的对象</li>
<li>原生在线HTTP&#x2F;S访问</li>
<li>通过在同一区域不同可用区间进行复制，持久性</li>
<li>面对Internet的对象存储</li>
</ul>
<p><code>Amazon Route 53</code><br>是一种可用性高、可扩展性强的云域名系统 (DNS) Web 服务，用于DNS域名服务。</p>
<p><code>IAM：Identity and Access Management</code><br>“身份识别与访问管理”，身份管理</p>
<p><code>DMZ</code><br>英文“demilitarized zone”的缩写，中文名称为“隔离区”，也称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</p>
<p><code>本地存储</code><br>本地存储适合临时存储不断变化的信息（如缓冲区、缓存、暂存数据和其他临时内容），或者在实例机群内复制的数据。</p>
<p><code>EBS</code><br>数据块存储 Elastic Block Store，相当于虚拟机硬盘，最大为1TB。实例依靠虚拟网络连接装载，持久性存储，可以重新附加在其他的EC2实例，利用快照实现，一个EC2实例可以有多个EBS卷，但是多个EC2不能共享卷。应用场景：简单硬盘设备；经常更改数据；对原始、未格式化数据块级别存储的访问权。</p>
<p><code>EBS快照</code><br>存储在S3中</p>
<p><code>RDS</code><br>Amazon Relational Database Service (Amazon RDS) 是一种可让用户在云中轻松设置、操作和扩展关系数据库的 Web 服务。它在管理耗时的数据库管理任务的同时，提供经济实用的可调容量，使您能够腾出时间专注于应用程序和业务。 RDS 让您能够访问非常熟悉的 MySQL、MariaDB、Oracle、Microsoft SQL Server 或 PostgreSQL 数据库引擎的功能。</p>
<p><code>AWS Elastic Beanstalk</code><br>是一项易于使用的服务，用于在熟悉的服务器（例如 Apache 、Nginx、Passenger 和 IIS）上部署和扩展使用 Java、.NET、PHP、Node.js、Python、Ruby、GO 和 Docker 开发的 Web 应用程序和服务。上传代码，Elastic Beanstalk 即可自动处理从容量预置、负载均衡、自动扩展到应用程序运行状况监控的部署。同时，您能够完全控制为应用程序提供支持的 AWS 资源，并可随时访问基础资源。</p>
<p><code>AWS SQS、SNS、SWF</code><br>消息发送各个工作流用</p>
<p><code>Amazon ElastiCache</code><br>缓存</p>
<p><code>Amazon Glacier</code><br>存档，将设置了生命周期规则（如90天）的S3存档，成本极低的存档存储服务，能够提供高耐久性存储，极低成本存储，允许在3-5小时内检索数据。可以利用Storage Gateway进行场外备份</p>
<p><code>安全性</code><br>SSL加密型终端节点、AES-256自动加密数据、IAM策略指定账户中的哪些用户有权对特定文件库执行操作</p>
<p><code>Amazon Simple Email Service</code><br>电子邮件<br><code>Auto Scaling</code><br>自动扩大或缩小Amazon EC2容量；响应需求峰值；当需求下降时，削减不需要的实例以节省费用；根据一天中的时间、按指标或通过API自动扩展</p>
<p><code>AMI</code><br>亚马逊系统映像，提供启动实例所需的信息</p>
<p><code>AWS Direct Connect</code><br>建立从本地设施到Amazon VPC的专用网络链接，建立AWS和数据中心、办公室或托管环境之间建立私有连接。</p>
<p><code>MSDN</code><br>Microsoft Developer Network用来帮助开发人员使用Microsoft产品和技术</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>AWS</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache负载均衡</title>
    <url>/hexoblog/2017/10/12/Apache%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/30/59f67be7cdb8c.jpg" alt="mahua"></p>
<span id="more"></span>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ul>
<li>轮询均衡策略的配置</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">ProxyPass /balancer://proxy/      #注意这里以<span class="string">&quot;/&quot;</span>结尾</span><br><span class="line">&lt;Proxy balancer://proxy&gt;</span><br><span class="line">      BalancerMember http://<span class="number">192.168</span>.<span class="number">6.37</span>:<span class="number">6888</span>/</span><br><span class="line">      BalancerMember http://<span class="number">192.168</span>.<span class="number">6.38</span>:<span class="number">6888</span>/</span><br><span class="line">&lt;/Proxy&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>按权重分配均衡策略的配置</li>
</ul>
<p>ProxyPass &#x2F;balancer:&#x2F;&#x2F;proxy&#x2F;       ProxyPass &#x2F; balancer:&#x2F;&#x2F;proxy&#x2F;协议地址可以随便定义。<br>ProxyPass指令允许你将一个远端服务器映射到本地服务器的URL空间中，此时本地服务器并不充当代理角色，而是充当远程服务器的一个镜像。path是一个本地虚拟路径名，url是一个指向远程服务器的部分URL，并且不允许包含查询字符串。<br><a href="http://www.jinbuguo.com/apache/menu22/mod/mod_proxy.html#proxypass">ProxyPass文档</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">&lt;Proxy balancer://proxy&gt;</span><br><span class="line">       BalancerMember http://<span class="number">192.168</span>.<span class="number">6.37</span>:<span class="number">6888</span>/ loadfactor=<span class="number">3</span></span><br><span class="line">       BalancerMember http://<span class="number">192.168</span>.<span class="number">6.38</span>:<span class="number">6888</span>/ loadfactor=<span class="number">1</span></span><br><span class="line">&lt;/Proxy&gt;</span><br></pre></td></tr></table></figure>

<p>参数”loadfactor”表示后台服务器负载到由Apache发送请求的权值,该值默认为1，可以将该值设置为1到100之间的任何值。</p>
<ul>
<li>权重请求响应负载均衡策略的配置</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">ProxyPass / balancer://proxy/ lbmethod=bytraffic 理解为LB的参数是流量</span><br><span class="line">&lt;Proxy balancer://proxy&gt;</span><br><span class="line">        BalancerMember http://<span class="number">192.168</span>.<span class="number">6.37</span>:<span class="number">6888</span>/ loadfactor=<span class="number">3</span></span><br><span class="line">        BalancerMember http://<span class="number">192.168</span>.<span class="number">6.38</span>:<span class="number">6888</span>/ loadfactor=<span class="number">1</span></span><br><span class="line">&lt;/Proxy&gt;</span><br></pre></td></tr></table></figure>
<p>参数“lbmethod&#x3D;bytraffic”表示后台服务器负载请求和响应的字节数，处理字节数的多少是以权值的方式来表示的。<br>(1)均衡配置，<br>(2)是以请求数作为权重负载均衡的，<br>(3)是以流量为权重负载均衡的，这是最大的区别。<br>lbmethod表示负载均衡的算法,lbmethod可能的取值有：</p>
<ul>
<li>lbmethod&#x3D;byrequests 按照请求次数均衡(默认)                 </li>
<li>lbmethod&#x3D;bytraffic 按照流量均衡，权重表示处理的比特流数据的权重</li>
<li>lbmethod&#x3D;bybusyness 按照繁忙程度均衡(总是分配给活跃请求数最少的服务器)</li>
</ul>
<p>httpd.conf 配置文件分为3个部分</p>
<p>Httpd.conf文件的路径：&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf或者&#x2F;usr&#x2F;local&#x2F;apache2&#x2F;conf&#x2F;httpd.conf分别对应的是RPM包安装和源码包安装两种安装方式的配置文件位置<br>第一部分：服务器全局环境配置<br>第二部分：本地服务器响应外部请求的处理方式的配置<br>第三部分：虚拟主机的配置</p>
<h2 id="主要配置过程"><a href="#主要配置过程" class="headerlink" title="主要配置过程"></a>主要配置过程</h2><p><strong>1、查看是否有mod_proxy_http.so、mod_proxy_balancer.so、mod_proxy.so三个模块</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$<span class="keyword">ll</span> /usr/local/apache2/modules</span><br></pre></td></tr></table></figure>

<p>mod_proxy<br>是一种分工合作的的形式，通过主服务器跳转到各台主机负责不同的任务而实现任务分工，这种形式不能实现负载均衡，只能提供主服务器的访问跳转<br><a href="http://www.jinbuguo.com/apache/menu22/mod/mod_proxy.html">Apache模块mod_proxy文档</a><br>Apache的代理功能(除mod_proxy以外)被划分到了几个不同的模块中：mod_proxy_http, mod_proxy_ftp, mod_proxy_ajp, mod_proxy_balancer, mod_proxy_connect 。这样，如果想使用一个或多个代理功能，就必须将mod_proxy和对应的模块同时加载到服务器中(静态连接或用LoadModule动态加载)。<br>mod_proxy_balancer<br>是mod_proxy的扩展，提供负载平衡支持，通过mod_proxy_balancer.so包实现负载平衡，公司生产服务器暂时就采用这种方式，粗略查看该文档发现，apache的balan<br>cer模块支持论询方式的负载均衡。<br><a href="http://www.jinbuguo.com/apache/menu22/mod/mod_proxy_balancer.html">apache模块mod_proxy_balancer文档</a></p>
<p><strong>2、加载模块</strong></p>
<p>apache模块安装：来自 <a href="http://unixboy.iteye.com/blog/577981">http://unixboy.iteye.com/blog/577981</a> 该模块可以是apache自己所拥有的模块 ，也可以是第三方模块。<br>加载第三方模块的方法：</p>
<ul>
<li>编译并安装已发布的Apache模块或者第三方模块，比如编译mod_foo.c为mod_foo.so的DSO模块，利用GCC编译的相关知识如：.&#x2F;configure  、 make install等</li>
<li>配置Apache以便以后安装共享模块</li>
<li>用apxs在Apache源码树以外编译并安装第三方模块，如：&#x2F;apxs -c -i</li>
<li>共享模块编译完毕后，必须在httpd.conf中用LoadModule指令使Apache启用该模块，如： LoadModule proxy_module</li>
</ul>
<p><a href="http://man.chinaunix.net/newsoft/ApacheMenual_CN_2.2new/programs/apxs.html">Apxs-Apache扩展工具</a><br><a href="http://blog.chinaunix.net/uid-20773865-id-113909.html">Apache DSO模块原理</a></p>
<p>apxs是一个为Apache HTTP服务器编译和安装扩展模块的工具，用于编译一个或多个源程序或目标代码文件为动态共享对象，使之可以用由mod_so提供的LoadModule指令在运行时加载到Apache服务器中。<br>DSO究竟是什么？事实上DSO是Dynamic SharedObjects（动态共享目标）的缩写，它是现代Unix派生出来的操作系统都存在着的一种动态连接机制。它提供了一种在运行时将特殊格式的代码，在程序运行需要时，将需要的部分从外存调入内存执行的方法。<br>-c：属于 DSO编译选项<br>此选项表示需要执行编译操作。它首先会编译C源程序(.c)files为对应的目标代码文件(.o)，然后连接这些目标代码和files中其余的目标代码文件(.o和.a)，以生成动态共享对象dsofile 。如果没有指定 -o 选项，则此输出文件名由files中的第一个文件名推测得到，也就是默认为mod_name.so 。<br>-i：DSO的安装和配置选项<br>此选项表示需要执行安装操作，以安装一个或多个动态共享对象到服务器的modules目录中。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">cd</span> /usr/local/src/httpd-<span class="number">2.2</span>.<span class="number">23</span>/modules/proxy/</span><br><span class="line"># /usr/local/apache2/bin/apxs -<span class="keyword">c</span> -i mod_proxy.<span class="keyword">c</span> proxy_util.<span class="keyword">c</span></span><br><span class="line"># /usr/local/apache2/bin/apxs -<span class="keyword">c</span> -i mod_proxy_balancer.<span class="keyword">c</span></span><br><span class="line"># /usr/local/apache2/bin/apxs -<span class="keyword">c</span> -i mod_proxy_http.<span class="keyword">c</span></span><br></pre></td></tr></table></figure>

<p><strong>3、修改http.conf配置文件</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">vim</span> /usr/local/apache2/<span class="keyword">conf</span>/httpd.<span class="keyword">conf</span></span><br><span class="line"> LoadModule proxy_module    modules/mod_proxy.<span class="keyword">so</span></span><br><span class="line"> LoadModule proxy_connect_module modules/mod_proxy_connect.<span class="keyword">so</span></span><br><span class="line"> LoadModule proxy_balancer_module modules/mod_proxy_balancer.<span class="keyword">so</span></span><br><span class="line"> LoadModule proxy_http_module  modules/mod_proxy_http.<span class="keyword">so</span></span><br><span class="line"> ProxyRequests Off</span><br><span class="line"> &lt;Proxy balancer://clusterphpinfo&gt;</span><br><span class="line"> BalancerMember http://<span class="number">10.0</span>.<span class="number">2.203</span>:<span class="number">80</span> loadfactor=<span class="number">1</span>;BalancerMember 及其后面的URL表示要配置的后台服务器、test表示该服务器下的项目名称</span><br><span class="line"> BalancerMember http://<span class="number">10.0</span>.<span class="number">2.204</span>:<span class="number">80</span> loadfactor=<span class="number">1</span>;参数”loadfactor”表示后台服务器负载到由Apache发送请求的权值,该值默认为<span class="number">1</span></span><br><span class="line"> &lt;/Proxy&gt;</span><br><span class="line"> ProxyPass / balancer://clusterphpinfo  用于做反向代理的配置，一般开启ProxyPass，ProxyRequests应该设置为off，即为关闭正向代理请求。</span><br></pre></td></tr></table></figure>

<p><strong>4、重启httpd服务</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># service httpd restart或者利用apachectl控制台操作# apachectl httpd restart</span><br></pre></td></tr></table></figure>

<p><strong>5、通过apache将后端服务器做出主从,只需要在从服务器后面添加status&#x3D;+H</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">vim</span> /usr/local/apache2/<span class="keyword">conf</span>/httpd.<span class="keyword">conf</span></span><br><span class="line"> BalancerMember http://<span class="number">10.0</span>.<span class="number">2.204</span>:<span class="number">80</span> loadfactor=<span class="number">1</span> status=+H</span><br></pre></td></tr></table></figure>
<p> 热备份(Hot Standby) ：热备份的实现很简单，只需添加 status&#x3D;+H 属性，就可以把某台服务器指定为备份服务器：请求总是流向服务器，一旦服务器挂掉，Apache会检测到错误并把请求分流给备份服务器。Apache会每隔几分钟检测一下原服务器的状况，如果原服务器恢复，就继续使用原服务器。</p>
<p> 参考资料：<br><a href="http://www.linuxidc.com/Linux/2014-09/106581.htm">Apache负载均衡的实现</a><br><a href="http://blog.csdn.net/navy_xue/article/details/39030879">Apache负载均衡之Apache Proxy方式</a><br>Apache负载均衡策略（轮询方式）<br><a href="http://blog.csdn.net/cnyygj/article/details/53352699">Apache策略原则</a><br>[apache模块mod_proxy_balancer文档](&lt;<a href="http://www.jinbuguo.com/apache/menu22/mod/mod_proxy_balancer.html">http://www.jinbuguo.com/apache/menu22/mod/mod_proxy_balancer.html</a>)</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra算法</title>
    <url>/hexoblog/2017/08/23/Dijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>文档资料：<br><a href="http://www.wutianqi.com/?p=1890">代码详解</a><br><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html">算法详解</a></p>
<p><strong><code>freopen函数</code></strong><br><a href="http://blog.chinaunix.net/uid-11600035-id-2866019.html">freopen妙用文档资料</a><br>因为文件指针使用的是标准流文件，因此我们可以不定义文件指针。<br>接下来我们使用freopen()函数以只读方式r(read)打开输入文件slyar.in</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;slyar.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br></pre></td></tr></table></figure>
<p>然后使用freopen()函数以写入方式w(write)打开输出文件slyar.out</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;slyar.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br></pre></td></tr></table></figure>
<p>单独使用stdin方法时候，系统有的时候会不读取我们自己创建的文件，这个时候的解决办法可以是写利用stdout输出一个txt的文件，然后将该文件改名并且填入需要输入的内容，作为stdio的文件。</p>
<p><strong><code>算法步骤：</code></strong></p>
<ul>
<li>a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U&#x3D;{其余顶点}，若v与U中顶点u有边，则&lt;u,v&gt;正常有权值，若u不是v的出边邻接点，则&lt;u,v&gt;权值为∞。</li>
<li>b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。</li>
<li>c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。</li>
<li>d.重复步骤b和c直到所有顶点都包含在S中<br><img src="https://i.loli.net/2017/10/20/59e99cc231939.png" alt="jiexi1"><br><img src="https://i.loli.net/2017/10/20/59e99cc2a104e.png" alt="jiexi2"></li>
</ul>
<p><strong><code>代码</code></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxnum = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxint = <span class="number">999999</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各数组都从下标1开始</span></span><br><span class="line"><span class="type">int</span> dist[maxnum];     <span class="comment">// 表示当前点到源点的最短路径长度</span></span><br><span class="line"><span class="type">int</span> prev[maxnum];     <span class="comment">// 记录当前点的前一个结点</span></span><br><span class="line"><span class="type">int</span> c[maxnum][maxnum];   <span class="comment">// 记录图的两点间路径长度</span></span><br><span class="line"><span class="type">int</span> n, line;             <span class="comment">// 图的结点数和路径数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// n -- n nodes</span></span><br><span class="line"><span class="comment">// v -- the source node</span></span><br><span class="line"><span class="comment">// dist[] -- the distance from the ith node to the source node</span></span><br><span class="line"><span class="comment">// prev[] -- the previous node of the ith node</span></span><br><span class="line"><span class="comment">// c[][] -- every two nodes&#x27; distance</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> v, <span class="type">int</span> *dist, <span class="type">int</span> *prev, <span class="type">int</span> c[maxnum][maxnum])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> s[maxnum];    <span class="comment">// 判断是否已存入该点到S集合中</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		dist[i] = c[v][i];</span><br><span class="line">		s[i] = <span class="number">0</span>;     <span class="comment">// 初始都未用过该点</span></span><br><span class="line">		<span class="keyword">if</span>(dist[i] == maxint)</span><br><span class="line">			prev[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			prev[i] = v;</span><br><span class="line">	&#125;</span><br><span class="line">	dist[v] = <span class="number">0</span>;</span><br><span class="line">	s[v] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 依次将未放入S集合的结点中，取dist[]最小值的结点，放入结合S中</span></span><br><span class="line">	<span class="comment">// 一旦S包含了所有V中顶点，dist就记录了从源点到所有其他顶点之间的最短路径长度</span></span><br><span class="line">         <span class="comment">// 注意是从第二个节点开始，第一个为源点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> tmp = maxint;</span><br><span class="line">		<span class="type">int</span> u = v;</span><br><span class="line">		<span class="comment">// 找出当前未使用的点j的dist[j]最小值</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">			<span class="keyword">if</span>((!s[j]) &amp;&amp; dist[j]&lt;tmp)</span><br><span class="line">			&#123;</span><br><span class="line">				u = j;              <span class="comment">// u保存当前邻接点中距离最小的点的号码</span></span><br><span class="line">				tmp = dist[j];</span><br><span class="line">			&#125;</span><br><span class="line">		s[u] = <span class="number">1</span>;    <span class="comment">// 表示u点已存入S集合中</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新dist</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">			<span class="keyword">if</span>((!s[j]) &amp;&amp; c[u][j]&lt;maxint)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> newdist = dist[u] + c[u][j];</span><br><span class="line">				<span class="keyword">if</span>(newdist &lt; dist[j])</span><br><span class="line">				&#123;</span><br><span class="line">					dist[j] = newdist;</span><br><span class="line">					prev[j] = u;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找从源点v到终点u的路径，并输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">searchPath</span><span class="params">(<span class="type">int</span> *prev,<span class="type">int</span> v, <span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> que[maxnum];</span><br><span class="line">	<span class="type">int</span> tot = <span class="number">1</span>;</span><br><span class="line">	que[tot] = u;</span><br><span class="line">	tot++;</span><br><span class="line">	<span class="type">int</span> tmp = prev[u];</span><br><span class="line">	<span class="keyword">while</span>(tmp != v)</span><br><span class="line">	&#123;</span><br><span class="line">		que[tot] = tmp;</span><br><span class="line">		tot++;</span><br><span class="line">		tmp = prev[tmp];</span><br><span class="line">	&#125;</span><br><span class="line">	que[tot] = v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=tot; i&gt;=<span class="number">1</span>; --i)</span><br><span class="line">		<span class="keyword">if</span>(i != <span class="number">1</span>)</span><br><span class="line">			cout &lt;&lt; que[i] &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout &lt;&lt; que[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">	<span class="keyword">if</span>( <span class="built_in">freopen</span>(<span class="string">&quot;input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin)== <span class="literal">NULL</span> )</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;false&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;open&quot;</span>&lt;&lt;endl;</span><br><span class="line">	<span class="comment">// 各数组都从下标1开始</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输入结点数</span></span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="comment">// 输入路径数</span></span><br><span class="line">	cin &gt;&gt; line;</span><br><span class="line">	<span class="type">int</span> p, q, len;          <span class="comment">// 输入p, q两点及其路径长度</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化c[][]为maxint</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">			c[i][j] = maxint;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=line; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; p &gt;&gt; q &gt;&gt; len;</span><br><span class="line">		<span class="keyword">if</span>(len &lt; c[p][q])       <span class="comment">// 有重边</span></span><br><span class="line">		&#123;</span><br><span class="line">			c[p][q] = len;      <span class="comment">// p指向q</span></span><br><span class="line">			c[q][p] = len;      <span class="comment">// q指向p，这样表示无向图</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">		dist[i] = maxint;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%8d&quot;</span>, c[i][j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Dijkstra</span>(n, <span class="number">1</span>, dist, prev, c);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最短路径长度</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;源点到最后一个顶点的最短路径长度: &quot;</span> &lt;&lt; dist[n] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 路径</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;源点到最后一个顶点的路径为: &quot;</span>;</span><br><span class="line">	<span class="built_in">searchPath</span>(prev, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2017/10/20/59e99c41573f8.png" alt="结果1"><br><img src="https://i.loli.net/2017/10/20/59e99c4179e4f.png" alt="结果2"></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker内核知识——Cgroup控制组</title>
    <url>/hexoblog/2017/09/14/Docker%E5%86%85%E6%A0%B8%E7%9F%A5%E8%AF%86%E2%80%94Cgroup%E6%8E%A7%E5%88%B6%E7%BB%84/</url>
    <content><![CDATA[<p><code>Linux Cgroup</code><br>Docker 容器使用 linux namespace 来隔离其运行环境，使得容器中的进程看起来就像爱一个独立环境中运行一样。但是，光有运行环境隔离还不够，因为这些进程还是可以不受限制地使用系统资源，比如网络、磁盘、CPU以及内存 等。关于其目的，一方面，是为了防止它占用了太多的资源而影响到其它进程；另一方面，在系统资源耗尽的时候，linux 内核会触发 OOM，这会让一些被杀掉的进程成了无辜的替死鬼。因此，为了让容器中的进程更加可控，Docker 使用 Linux cgroups 来限制容器中的进程允许使用的系统资源。<br>Linux Cgroup 可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU 时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​ cgroup，拒​​​绝​​​ cgroup 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​ cgroup。所以，可以将 controll groups 理解为 controller （system resource） （for） （process）groups，也就是是说它以一组进程为目标进行系统资源分配和控制。<br>功能：</p>
<ul>
<li>Resource limitation: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。</li>
<li>Prioritization: 优先级控制，比如：CPU利用和磁盘IO吞吐。</li>
<li>Accounting: 一些审计或一些统计，主要目的是为了计费。</li>
<li>Control: 挂起进程，恢复执行进程。</li>
</ul>
<p>使​​​用​​​ cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。</p>
<p><code>在实践中：系统管理员一般会利用CGroup做下面这些事</code><br>（有点像为某个虚拟机分配资源似的）：</p>
<ul>
<li>隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。</li>
<li>为这组进程分配其足够使用的内存</li>
<li>为这组进程分配相应的网络带宽和磁盘存储限制</li>
<li>限制访问某些设备（通过设置设备的白名单）</li>
</ul>
<p><code>子系统说明</code><br>cgroups 实现了对资源的配额和度量。cgroups 的使用非常简单，提供类似文件的接口，在 &#x2F;cgroup目录下新建一个文件夹即可新建一个group，在此文件夹中新建task文件，并将pid写入该文件，即可实现对该进程的资源控制。groups可以限制blkio、cpu、cpuacct、cpuset、devices、freezer、memory、net_cls、ns九大子系统的资源，以下是每个子系统的详细说明：</p>
<ul>
<li>blkio 这个子系统设置限制每个块设备的输入输出控制。例如:磁盘，光盘以及usb等等。</li>
<li>cpu 这个子系统使用调度程序为cgroup任务提供cpu的访问。</li>
<li>cpuacct 产生cgroup任务的cpu资源报告。</li>
<li>cpuset 如果是多核心的cpu，这个子系统会为cgroup任务分配单独的cpu和内存。</li>
<li>devices 允许或拒绝cgroup任务对设备的访问。</li>
<li>freezer 暂停和恢复cgroup任务。</li>
<li>memory 设置每个cgroup的内存限制以及产生内存资源报告。</li>
<li>net_cls 标记每个网络包以供cgroup方便使用。</li>
<li>ns 名称空间子系统。</li>
</ul>
<p><a href="http://www.cnblogs.com/sammyliu/p/5886833.html">参考资料</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>docker</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker内核知识——AUFS及安全性</title>
    <url>/hexoblog/2017/09/14/Docker%E5%86%85%E6%A0%B8%E7%9F%A5%E8%AF%86%E2%80%94AUFS%E5%8F%8A%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<p><code>关于 AUFS（联合文件系统） 的几个特点：</code></p>
<ul>
<li>AUFS 是一种联合文件系统，它把若干目录按照顺序和权限 mount 为一个目录并呈现出来</li>
<li>默认情况下，只有第一层（第一个目录）是可写的，其余层是只读的。</li>
<li>增加文件：默认情况下，新增的文件都会被放在最上面的可写层中。</li>
<li>删除文件：因为底下各层都是只读的，当需要删除这些层中的文件时，AUFS 使用 whiteout 机制，它的实现是通过在上层的可写的目录下建立对应的whiteout隐藏文件来实现的。</li>
<li>修改文件：AUFS 利用其 CoW （copy-on-write）特性来修改只读层中的文件。AUFS 工作在文件层面，因此，只要有对只读层中的文件做修改，不管修改数据的量的多少，在第一次修改时，文件都会被拷贝到可写层然后再被修改。</li>
<li>节省空间：AUFS 的 CoW 特性能够允许在多个容器之间共享分层，从而减少物理空间占用。</li>
<li>查找文件：AUFS 的查找性能在层数非常多时会出现下降，层数越多，查找性能越低，因此，在制作 Docker 镜像时要注意层数不要太多。</li>
<li>性能：AUFS 的 CoW 特性在写入大型文件时第一次会出现延迟。</li>
</ul>
<p><code>一个Linux 系统之中</code></p>
<ul>
<li>所有 Docker 容器都共享主机系统的 bootfs 即 Linux 内核</li>
<li>每个容器有自己的 rootfs，它来自不同的 Linux 发行版的基础镜像，包括 Ubuntu，Debian 和 SUSE 等</li>
<li>在操作系统镜像上面一层层附加应用程序的开源组件的镜像</li>
<li>所有基于一种基础镜像的容器都共享这种 rootfs</li>
</ul>
<p><img src="https://i.loli.net/2017/10/26/59f168e853994.png" alt="tu"></p>
<p><code>安全性: </code></p>
<p>AppArmor, SELinux, GRSEC<br>安全永远是相对的，这里有三个方面可以考虑Docker的安全特性:</p>
<ul>
<li>由kernel namespaces和cgroups实现的Linux系统固有的安全标准;</li>
<li>Docker Deamon的安全接口;</li>
<li>Linux本身的安全加固解决方案,类如AppArmor, SELinux;</li>
</ul>
<p>资料参考：<br><a href="http://www.infoq.com/cn/articles/docker-core-technology-preview/">内核知识资料</a><br><a href="http://www.cnblogs.com/sammyliu/p/5931383.html">AUFS</a><br><a href="http://www.infoq.com/cn/articles/docker-core-technology-preview/">安全性</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>docker</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker内核知识——namespace</title>
    <url>/hexoblog/2017/09/15/Docker%E5%86%85%E6%A0%B8%E7%9F%A5%E8%AF%86%E2%80%94namespace/</url>
    <content><![CDATA[<p>为了在分布式的环境下进行通信和定位，容器必然需要一个独立的IP、端口、路由等等，自然就想到了网络的隔离。同时，你的容器还需要一个独立的主机名以便在网络中标识自己。想到网络，顺其自然就想到通信，也就想到了进程间通信的隔离。可能你也想到了权限的问题，对用户和用户组的隔离就实现了用户权限的隔离。最后，运行在容器中的应用需要有自己的PID,自然也需要与宿主机中的PID进行隔离。<br>Linux内核中就提供了这六种namespace隔离的系统调用，如下表所示。</p>
<table>
<thead>
<tr>
<th>Namespace</th>
<th>系统调用参数</th>
<th>隔离内容</th>
</tr>
</thead>
<tbody><tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>主机名与域名</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>信号量、消息队列和共享内存</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>进程编号</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>网络设备、网络栈、端口等等</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>挂载点（文件系统）</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>用户和用户组</td>
</tr>
</tbody></table>
<p>实现轻量级虚拟化（容器）服务。在同一个namespace下的进程可以感知彼此的变化，而对外界的进程一无所知。这样就可以让容器中的进程产生错觉，仿佛自己置身于一个独立的系统环境中，以此达到独立和隔离的目的。</p>
<hr>
<p><strong><code>六种namespace具体介绍 </code></strong></p>
<p><strong>UTS namespace</strong><br>提供了主机名和域名的隔离，这样每个容器就可以拥有了独立的主机名和域名，在网络上可以被视作一个独立的节点而非宿主机上的一个进程。Docker中，每个镜像基本都以自己所提供的服务命名了自己的hostname而没有对宿主机产生任何影响，用的就是这个原理。</p>
<p><strong>IPC</strong><br>容器中进程间通信采用的方法包括常见的信号量、消息队列和共享内存。然而与虚拟机不同的是，容器内部进程间通信对宿主机来说，实际上是具有相同PID namespace中的进程间通信，因此需要一个唯一的标识符来进行区别。申请IPC资源就申请了这样一个全局唯一的32位ID，所以IPC namespace中实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，而与其他的IPC namespace下的进程则互相不可见。目前使用IPC namespace机制的系统不多，其中比较有名的有PostgreSQL。Docker本身通过socket或tcp进行通信</p>
<p><strong>PID namespace</strong><br>隔离非常实用，它对进程PID重新标号，即两个不同namespace下的进程可以有同一个PID。每个PID namespace都有自己的计数程序。内核为所有的PID namespace维护了一个树状结构，最顶层的是系统初始时创建的，我们称之为root namespace。他创建的新PID namespace就称之为child namespace（树的子节点），而原先的PID namespace就是新创建的PID namespace的parent namespace（树的父节点）。通过这种方式，不同的PID namespaces会形成一个等级体系。所属的父节点可以看到子节点中的进程，并可以通过信号等方式对子节点中的进程产生影响。反过来，子节点不能看到父节点PID namespace中的任何内容。由此产生如下结论<br><a href="http://blog.dotcloud.com/under-the-hood-linux-kernels-on-dotcloud-part">部分内容引自</a>
	</p>
<ul>
<li>每个PID namespace中的第一个进程“PID 1“，都会像传统Linux中的init进程一样拥有特权，起特殊作用。</li>
<li>一个namespace中的进程，不可能通过kill或ptrace影响父节点或者兄弟节点中的进程，因为其他节点的PID在这个namespace中没有任何意义。</li>
<li>如果你在新的PID namespace中重新挂载&#x2F;proc文件系统，会发现其下只显示同属一个PID namespace中的其他进程。</li>
<li>在root namespace中可以看到所有的进程，并且递归包含所有子节点中的进程。</li>
</ul>
<p>在外部监控Docker中运行程序的方法：监控Docker Daemon所在的PID namespace下的所有进程即其子进程，再进行删选即可<br>附：Docker Daemon是Docker架构中运行在后台的守护进程，大致可以分为Docker Server、Engine和Job三部分。Docker Daemon可以认为是通过Docker Server模块接受Docker Client的请求，并在Engine中处理请求，然后根据请求类型，创建出指定的Job并运行，运行过程的作用有以下几种可能：向Docker Registry获取镜像，通过graphdriver执行容器镜像的本地化操作，通过networkdriver执行容器网络环境的配置，通过execdriver执行容器内部运行的执行工作等。<br><a href="http://www.infoq.com/cn/articles/docker-source-code-analysis-part3/">docker Daemon</a></p>
<p><strong>Mount namespace</strong><br>通过隔离文件系统挂载点对隔离文件系统提供支持，它是历史上第一个Linux namespace，所以它的标识位比较特殊，就是CLONE_NEWNS。隔离后，不同mount namespace中的文件结构发生变化也互不影响。你可以通过&#x2F;proc&#x2F;[pid]&#x2F;mounts查看到所有挂载在当前namespace中的文件系统，还可以通过&#x2F;proc&#x2F;[pid]&#x2F;mountstats看到mount namespace中文件设备的统计信息，包括挂载文件的名字、文件系统类型、挂载位置等等。<br>进程在创建mount namespace时，会把当前的文件结构复制给新的namespace。新namespace中的所有mount操作都只影响自身的文件系统，而对外界不会产生任何影响。这样做非常严格地实现了隔离，但是某些情况可能并不适用。比如父节点namespace中的进程挂载了一张CD-ROM，这时子节点namespace拷贝的目录结构就无法自动挂载上这张CD-ROM，因为这种操作会影响到父节点的文件系统。<br>挂载状态：共享挂载（shared）、从属挂载（slave）、共享&#x2F;从属挂载（shared and slave）、私有挂载（private）、不可绑定挂载（unbindable）</p>
<p><strong>Network namespace</strong><br>Network namespace主要提供了关于网络资源的隔离，包括网络设备、IPv4和IPv6协议栈、IP路由表、防火墙、&#x2F;proc&#x2F;net目录、&#x2F;sys&#x2F;class&#x2F;net目录、端口（socket）等等。一个物理的网络设备最多存在在一个network namespace中，你可以通过创建veth pair（虚拟网络设备对：有两端，类似管道，如果数据从一端传入另一端也能接收到，反之亦然）在不同的network namespace间创建通道，以此达到通信的目的。</p>
<p><strong>User namespaces</strong><br>User namespace主要隔离了安全相关的标识符（identifiers）和属性（attributes），包括用户ID、用户组ID、root目录、key（指密钥）以及特殊权限。说得通俗一点，一个普通用户的进程通过clone()创建的新进程在新user namespace中可以拥有不同的用户和用户组。这意味着一个进程在容器外属于一个没有特权的普通用户，但是他创建的容器进程却属于拥有所有权限的超级用户，这个技术为容器提供了极大的自由。</p>
<p><a href="http://www.infoq.com/cn/articles/docker-kernel-knowledge-namespace-resource-isolation">参考资料来源</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>docker</tag>
        <tag>内核</tag>
      </tags>
  </entry>
  <entry>
    <title>Git基础教程</title>
    <url>/hexoblog/2017/10/20/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/27/59f2a5d1d9fee.jpg" alt="tu"></p>
<span id="more"></span>
<h2 id="新建一个仓库添加本地上传服务："><a href="#新建一个仓库添加本地上传服务：" class="headerlink" title="新建一个仓库添加本地上传服务："></a>新建一个仓库添加本地上传服务：</h2><p><strong>现在的情景:</strong><br>你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。<br>对于新创建的仓库，从本地做备份到github网站上gitbash的代码段如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">echo</span> <span class="string">&quot;# learngit.github.io&quot;</span> &gt;&gt; README.md</span><br><span class="line">$ git init</span><br><span class="line">$ git <span class="built_in">add</span> README.md</span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">&quot;first commit&quot;</span></span><br><span class="line">$ git remote <span class="built_in">add</span> origin git@github.<span class="keyword">com</span>:dclarken/dai.github.io.git</span><br><span class="line">$ git push -<span class="keyword">u</span> origin master</span><br></pre></td></tr></table></figure>

<p><strong>操作解释：</strong></p>
<ul>
<li>新建一个README文件；</li>
<li>初始化本地文件得到一个.git的隐藏文件，用于追踪地位；</li>
<li>添加README文件到缓存区；</li>
<li>给刚刚添加的文件记录cmmit信息，便于以后管理，并且通过该操作将缓存区的文件上传到master分支上；</li>
<li>在本地远程建立与github仓库的连接；</li>
<li>利用push将上传到master的文件发布到github网站上；</li>
</ul>
<p><strong>error:src refspec master does not match any</strong></p>
<p><strong>原因：</strong><br>引起该错误的原因是，目录中没有文件，空目录是不能提交上去的</p>
<p><strong>解决方法：</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ touch README</span><br><span class="line">$ git <span class="built_in">add</span> README </span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="本地和远程仓库建立连接之后，如何添加和修改文件："><a href="#本地和远程仓库建立连接之后，如何添加和修改文件：" class="headerlink" title="本地和远程仓库建立连接之后，如何添加和修改文件："></a>本地和远程仓库建立连接之后，如何添加和修改文件：</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">add</span> <span class="string">&quot;filename&quot;</span>          添加文件到缓存区 ；</span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">&quot;add/update….&quot;</span>给刚刚添加的文件记录cmmit信息；</span><br><span class="line">$ git push                    利用push将上传到master的文件发布到github网站上；</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="本地删除文件并且同步到仓库上："><a href="#本地删除文件并且同步到仓库上：" class="headerlink" title="本地删除文件并且同步到仓库上："></a>本地删除文件并且同步到仓库上：</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git rm filename</span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">&quot;remove filename&quot;</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p>对于新建和删除修改文件的小结：<br>这些操作都需要三个步骤：</p>
<ul>
<li>修改&#x2F;删除&#x2F;新建</li>
<li>添加commit</li>
<li>git push上传到github</li>
</ul>
<p>另外：<br>git pull –rebase 从github上下拉到本地，进行同步工作，加上–rebase可以避免跳入merge commit窗口，从而导致的无用记录,一般来说在网页上直接操作即使没有添加commit也会自动添加，但是为了记录好看还是养成加–rebase的习惯吧<br><a href="http://www.cnblogs.com/wangiqngpei557/p/6056624.html">聊下git pull –rebase</a><br>git status可以查看当前的修改情况<br>git checkout – file 让这个文件回到最近一次git commit或git add时的状态。<br>git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区</p>
<hr>
<h2 id="将一个已有的github仓库clone到新创建的learngit以及本地仓库中："><a href="#将一个已有的github仓库clone到新创建的learngit以及本地仓库中：" class="headerlink" title="将一个已有的github仓库clone到新创建的learngit以及本地仓库中："></a>将一个已有的github仓库clone到新创建的learngit以及本地仓库中：</h2><ul>
<li>在github上创建项目</li>
<li>使用 git clone <a href="mailto:&#103;&#x69;&#116;&#64;&#103;&#x69;&#x74;&#x68;&#117;&#98;&#46;&#99;&#x6f;&#x6d;">git@github.com</a>:dclarken&#x2F;dclarken.github.io.git克隆到本地</li>
<li>编辑项目</li>
<li>git add “dclarken.github.io&#x2F;“</li>
<li>git commit -m “clone dclarken.github.io&#x2F; “</li>
<li>git push origin master 将本地更改推送到远程master分支。</li>
</ul>
<p>如果在github的remote上已经有了文件，会出现错误。此时应当先pull一下，即：<br>git pull origin master</p>
<hr>
<h2 id="上传时候的某报错："><a href="#上传时候的某报错：" class="headerlink" title="上传时候的某报错："></a>上传时候的某报错：</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">To github.<span class="keyword">com</span>:dclarken/learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed <span class="keyword">to</span> push some refs <span class="keyword">to</span> <span class="string">&#x27;git@github.com:dclarken/learngit.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because the tip of your current branch <span class="keyword">is</span> behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote <span class="keyword">changes</span> (<span class="keyword">e</span>.g.</span><br><span class="line">hint: <span class="string">&#x27;git pull ...&#x27;</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">&#x27;Note about fast-forwards&#x27;</span> in <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong><br>GitHub远程仓库中的README.md文件不在本地仓库中。</p>
<p><strong>解决方案：</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git pull --rebase origin master</span><br><span class="line">$ git push -<span class="keyword">u</span> origin master</span><br></pre></td></tr></table></figure>

<p>若此时又出现报错或者在平时也有这种报错：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Git Cannot rebase: You have unstaged <span class="keyword">changes</span>.</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong><br>那说明有修改过的文件</p>
<p><strong>解决方案：</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git pull --rebase （每次push之前最好这样做一次）</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>之后用git stash pop stash</p>
<p><strong>解析：</strong></p>
<p>git stash 可用来暂存当前正在进行的工作， 比如想pull 最新代码， 又不想加新commit， 或者另外一种情况，为了fix 一个紧急的bug,  先stash, 使返回到自己上一个commit, 改完bug之后再stash pop, 继续原来的工作。所以以前自己在网页上面直接上传代码时，经常不写commit于是在想要添加本地管理的时候，会出现以上报错。</p>
<p>基础命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ <span class="keyword">do</span> some work</span><br><span class="line">$ git stash <span class="keyword">pop</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="添加一个文件夹并且上传到github："><a href="#添加一个文件夹并且上传到github：" class="headerlink" title="添加一个文件夹并且上传到github："></a>添加一个文件夹并且上传到github：</h2><p>其实这个和上传文件的原理一样，github支持在上传某个文件夹下的文件的时，将文件夹也上传。所以：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> CodeCut</span><br><span class="line">$ <span class="keyword">cd</span> CodeCut</span><br><span class="line">$ touch test.txt</span><br><span class="line">$ git <span class="built_in">add</span> <span class="string">&quot;test.txt&quot;</span></span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">&quot; add test.txt&quot;</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>

<h2 id="本地更改目录结构同步到远程仓库："><a href="#本地更改目录结构同步到远程仓库：" class="headerlink" title="本地更改目录结构同步到远程仓库："></a>本地更改目录结构同步到远程仓库：</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git mv filefrom dir/  #移动操作</span><br><span class="line">$ …#多次移动操作</span><br><span class="line">$ git <span class="built_in">add</span> .</span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">&quot;Modified directory structure&quot;</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>文件改名</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git mv oldfile newfile  #改名操作</span><br><span class="line">$ …#多次改名操作</span><br><span class="line">$ git <span class="built_in">add</span> .</span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">&quot;Change file name&quot;</span></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>


<p><a href="http://www.yiibai.com/git/git_move_operation.html">git移动操作资料</a></p>
<h2 id="报错–hexo-g执行报错，提示缺少hexo-util"><a href="#报错–hexo-g执行报错，提示缺少hexo-util" class="headerlink" title="报错–hexo g执行报错，提示缺少hexo-util"></a>报错–hexo g执行报错，提示缺少hexo-util</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">ERROR Script load failed: themes/hexo-theme-<span class="keyword">next</span>/scripts/<span class="keyword">tags</span>/exturl.js  </span><br><span class="line">Error: Cannot <span class="keyword">find</span> module <span class="string">&#x27;hexo-util&#x27;</span> </span><br></pre></td></tr></table></figure>
<p>Cannot find module ‘hexo-util’<br>发现提示hexo-util找不到,<br>执行下面命令后就可以了</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">npm install hexo-util --save</span><br></pre></td></tr></table></figure>

<p>资料参考：<br><a href="https://www.liaoxuefeng.com/">廖学峰官方网站</a><br><a href="http://blog.csdn.net/u011471873/article/details/51462871">error: failed to push some refs to ‘git@github.com:</a><br><a href="http://blog.csdn.net/u012385190/article/details/70670213">error:Cannot pull with rebase</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s结合LVS高可用负载均衡与集群外服务访问实践</title>
    <url>/hexoblog/2017/09/24/K8s%E7%BB%93%E5%90%88LVS%E9%AB%98%E5%8F%AF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8E%E9%9B%86%E7%BE%A4%E5%A4%96%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p><a href="https://www.kubernetes.org.cn/2812.html">文档资料</a><br><a href="http://docs.kubernetes.org.cn/">K8s官方文档翻译</a></p>
<h2 id="Kubernetes平台Ingress-介绍"><a href="#Kubernetes平台Ingress-介绍" class="headerlink" title="Kubernetes平台Ingress 介绍"></a>Kubernetes平台Ingress 介绍</h2><p>Ingress 是一个规则的集合，它允许集群外的流量通过一定的规则到达集群内的 Service 。<br>Ingress三个组件:</p>
<ul>
<li>反向代理负载均衡器<br>反向代理负载均衡器，即常见的负载均衡软件，如 nginx、Haproxy 等。</li>
<li>Ingress Controller<br>Ingress Controller 与 kubernetes API 进行交互，实时的感知后端 service、pod 等变化， Ingress Controller 再结合下文的 Ingress 生成配置，然后更新反向代理负载均衡器，并刷新其配置，实现动态服务发现与更新。</li>
<li>Ingress<br>Ingress是规则集合；定义了域名与Kubernetes的service的对应关系;这个规则将与 Ingress Controller 结合， Ingress Controller 将其动态写入到负载均衡器配置中，从而实现整体的服务发现和负载均衡。</li>
</ul>
<p><code>Traefik</code><br>Træfɪk 是一个为了让部署微服务更加便捷而诞生的现代HTTP反向代理、负载均衡工具。 它支持多种后台来自动化、动态的应用它的配置文件设置。<br>特性：</p>
<ul>
<li>它非常快</li>
<li>无需安装其他依赖，通过Go语言编写的单一可执行文件</li>
<li>支持 Rest API</li>
<li>多种后台支持：Docker, Swarm, Kubernetes, Marathon, Mesos, Consul, Etcd</li>
<li>后台监控, 可以监听后台变化进而自动化应用新的配置文件设置</li>
<li>配置文件热更新。无需重启进程:Traefik 可以与Kubernetes的API进行交互，每当Kubernetes使用Ingress对微服务进行添加、移除、或更新都会被感知，并且可以自动生成它们的配置文件。 指向到你服务的路由将会被直接创建出来。</li>
<li>正常结束http连接</li>
<li>后端断路器</li>
<li>轮询，rebalancer 负载均衡</li>
<li>Rest Metrics</li>
<li>支持最小化 官方 docker 镜像</li>
<li>后台支持SSL</li>
<li>前台支持SSL（包括SNI）</li>
<li>清爽的AngularJS前端页面</li>
<li>支持Websocket</li>
<li>支持HTTP&#x2F;2</li>
<li>网络错误重试</li>
<li>支持Let’s Encrypt (自动更新HTTPS证书)</li>
<li>高可用集群模式</li>
</ul>
<hr>
<h2 id="K8s结合LVS高可用负载均衡与集群外服务访问组网拓扑："><a href="#K8s结合LVS高可用负载均衡与集群外服务访问组网拓扑：" class="headerlink" title="K8s结合LVS高可用负载均衡与集群外服务访问组网拓扑："></a>K8s结合LVS高可用负载均衡与集群外服务访问组网拓扑：</h2><p>这个案例也可以学习为：如何将四层负载均衡和七层负载均衡相结合来实现对外访问服务。</p>
<p>组网思路如下：</p>
<ul>
<li>前端为两台LVS服务器，通过keepalive实现负载集群高可用以及虚拟IP，实现外部流量的四层负载，以及作为Kubernetes集群服务访问的入口。LVS负载均衡采用DR模式提高集群的处理速度。</li>
<li>后端三台服务器组成Kubernetes集群，每台节点使用hostPort 的方式部署traefik容器（或者其他能够实现反向代理与负载均衡的服务器如nginx），traefik监听节点的80端口，前端LVS负载均衡监听后端三台Kubernetes节点的80端口将外部访问负载分担至traefik。</li>
<li>然后由Traefik进行七层负载均衡，可以实现基于域名或访问目录等来实现映射与负载，将访问流量映射至Kubernetes Service并通过Service负载至最终业务POD所在的容器。<br><img src="https://i.loli.net/2017/10/20/59e9a4894e40e.png" alt="tu1"><br><img src="https://i.loli.net/2017/10/20/59e9a4895b6d8.png" alt="tu2"></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s集群基本组成</title>
    <url>/hexoblog/2017/09/19/K8s%E9%9B%86%E7%BE%A4%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/chris-cp/p/5766153.html%3E">K8s集群基本概念</a><br>Kubernetes 是Google开源的容器集群管理系统，它构建于docker技术之上，基于Docker构建一个容器的调度服务，提供资源调度、均衡容灾、服务注册、动态扩缩容等功能套件，本质上可看作是基于容器技术的mini-PaaS平台。</p>
<p><strong><code>基本概念：</code></strong><br><code>Node:</code><br>Node也就等同于Mesos集群中的Slave节点，是所有Pod运行所在的工作主机，可以是物理机也可以是虚拟机。不论是物理机还是虚拟机，工作主机的统一特征是上面要运行kubelet管理节点上运行的容器。</p>
<p><code>Pod:</code><br>若干相关容器的组合，Pod包含的容器运行在同一host上，这些容器使用相同的网络命令空间、IP地址和端口，相互之间能通过localhost来发现和通信。另外，这些容器还可共享一块存储卷空间。在k8s中创建，调度和管理的最小单位就是Pod，而非容器，Pod通过提供更高层次的抽象，提供了更加灵活的部署和管理模式；
	</p>
<ul>
<li>k8s的基本操作单元，一个Pod由一个或多个容器组成，通常pod里的容器运行的相同的应用；一个容器相当于一个进程，”一个容器一个进程”的原则，一个pod含有多个容器，就像虚拟机工作时有多个进程在执行操作，POD中的所有容器都是并行启动。结合多个容器集成进单一的Kubernetes节点pod，即容器互联通信。</li>
<li>同一pod包含的容器运行在同一host上，作为统一管理单元：同一pod 共享着相同的volumes， network命名空间， ip和port空间，这是通过 Mapped Container做到的；  </li>
<li>pid ns：处于同一pod中的应用可以看到彼此的进程</li>
<li>network ns：处于同一pod中的应用可以访问一样的ip和port空间</li>
<li>ipc ns：处于同一pod的应用可以用systemV ipc 或者posix消息队列进行通信</li>
<li>UTC ns：处于同一pod应用共用一个主机名</li>
</ul>
<p>多容器POD的主要用途是支持主要应用程序的共定位、共管辅助进程。</p>
<ul>
<li>跨斗容器“帮助”主容器。示例包括日志或数据更改监视程序、监视适配器等。例如，日志监视程序可以由一个团队创建一次，并在不同的应用程序中重用。另一个例子，一个跨斗容器是一个文件或数据装载器，为主容器生成数据。</li>
<li>代理、网桥和适配器将主容器与外部世界连接起来。例如，Apache HTTP服务器或Nginx可以提供静态文件。它还可以充当主容器中Web应用程序的反向代理，以记录和限制HTTP请求。另一个例子是辅助容器，它将请求从主容器路由到外部网络。这使得主容器可以连接到本地主机访问，例如，外部数据库，但不需任何的服务发现。</li>
</ul>
<p>Pod容器间的通信：<br><a href="https://www.kubernetes.org.cn/2767.html">Pod介绍</a></p>
<ul>
<li>在Kubernetes Pod中共享卷，使用一个共享的Kubernetes卷作为一种简单而有效的方式，在一个POD内容器间进行数据共享。</li>
<li>进程间通信（IPC），一个POD里的容器共享相同的IPC命名空间，这意味着他们也可以互相使用标准进程间通信，如SystemV信号系统或POSIX共享内存。</li>
</ul>
<p><code>ReplicationController （RC）</code>
	</p>
<ul>
<li>RC是用来管理Pod的，每个RC由一个或多个Pod组成；在RC被创建之后，系统将会保持RC中的可用Pod的个数与创建RC时定义的Pod个数一致，如果Pod个数小于定义的个数，RC会启动新的Pod，反之则会杀死多余的Pod。</li>
<li>RC通过定义的Pod模板被创建，创建后对象叫做Pods（也可以理解为RC），可以在线修改Pods的属性，以实现动态缩减、扩展Pods的规模</li>
<li>RC通过label关联对应的Pods，通过修改Pods的label可以删除对应的Pods在需要对Pods中的容器进行更新时，RC采用一个一个替换原则来更新整个Pods中的Pod；</li>
<li>reschudeling: 维护pod副本，“多退少补”；即使是某些minion宕机</li>
<li>scaling：通过修改rc的副本数来水平扩展或者缩小运行的pods</li>
<li>Rolling updates:一个一个地替换pods来rolling updates服务；</li>
<li>multiple release tracks：如果需要在系统中运行multiple release 服务，replication controller使用labels来区分multiple release tracks</li>
</ul>
<p><code>Label</code></p>
<ul>
<li>Label是用于区分Pod、Service、RC的key&#x2F;value键值对</li>
<li>Pod、Service、RC可以有多个label，但是每个label的key只能对应一个value</li>
<li>整个系统都是通过Label进行关联，得到真正需要操作的目标</li>
</ul>
<p><code>Service</code></p>
<ul>
<li>Service也是k8s的最小操作单元，是真实应用服务的抽象</li>
<li>Service通常用来将浮动的资源与后端真实提供服务的容器进行关联</li>
<li>Service对外表现为一个单一的访问接口，外部不需要了解后端的规模与机制</li>
<li>Service是定义在集群中一组运行Pod集合的抽象资源，它提供了所有相同的功能。当一个Service资源被创建后，将会分配一个唯一的IP（也叫做集群IP），这个IP地址将存在于Service的整个生命资源，Service一旦被创建，整个IP无法进行修改。</li>
</ul>
<p>Pod可以通过Service进行通信，并且所有的通信将会通过Service自动负载均很到所有的Pod中的容器，service是抽象化的pod，为集群提供服务。</p>
<p><code>目前 kubernetes 共有三种服务暴露的方式:</code><br><a href="https://www.kubernetes.org.cn/2812.html">K8s集群外服务访问</a></p>
<ul>
<li>LoadBlancer Service<br>LoadBlancer Service是kubernetes深度结合云平台的一个组件；当使LoadBlancer Service暴露服务时，实际上是通过向底层云平台申请创建一个负载均衡器来向外暴露服务；目前LoadBlancer Service支持的云平台已经相对完善，比如国外的GCE、DigitalOcean，国内的 阿里云，私有云 OpenStack 等等，由于LoadBlancer Service深度结合了云平台，所以只能在一些云平台上来使用。</li>
<li>NodePort Service<br>NodePort Service，实质上就是通过在集群的每个node上暴露一个端口，然后将这个端口映射到某个具体的service来实现的，虽然每个node的端口有很多(默认的取值范围是 30000-32767)，例如：在做反向代理服务器时候，将nginx的80端口映射到30000端口，然后将30000端口暴露，用于做对外服务，但是由于安全性和易用性(服务多了就乱了，还有端口冲突问题)实际使用可能并不多。</li>
<li>Ingress<br>Ingress可以实现使用nginx等开源的反向代理负载均衡器实现对外暴露服务，可以理解Ingress就是用于配置域名转发，在nginx中就类似upstream，它与ingress-controller结合使用，通过ingress-controller监控到pod及service的变化，动态地将ingress中的转发信息写到诸如nginx、apache、haproxy等组件中实现方向代理和负载均衡。</li>
</ul>
<hr>
<p><strong><code>kubernetes组成</code></strong>　</p>
<ul>
<li>kubectl 客户端命令行工具：将接收的命令，发送给kube-apiserver，作为对整个平台操作的入口。</li>
<li>kube-apiserver　REST API服务：作为整个系统的控制入口，以REST API的形式公开，可以横向扩展在高可用的架构中。</li>
<li>kube-controller-manager 多个控制器的合体，用来执行整个系统中的后台任务，多个控制进程的合体：</li>
<li>Node Controller 负责整个系统中node up 或down的状态的响应和通知</li>
<li>Replication Controller 负责维持Pods中的正常运行的Pod的个数</li>
<li>Endpoints Controller 负责维持Pods和Service的关联关系</li>
<li>Service Account &amp; Token Controllers负责为新的命名空间创建默认的账号和API访问的Token　　　　</li>
<li>kube-scheduler　任务调度、命令下发,负责监视新创建的Pods任务，下发至未分配的节点运行该任务</li>
<li>kube-proxy　网络代理转发：kube-proxy运行在每个节点上，负责整个网络规则的连接与转发，使k8s中的service更加抽象化，为Service提供cluster内部的服务发现和负载均衡</li>
<li>kubelet　容器的管理,kubelet运行在每个节点上，作为整个系统的agent，监视着分配到该节点的Pods任务，负责挂载Pods所依赖的卷组，下载Pods的秘钥，运行Pods中的容器（通常是docker），周期获取所有容器的状态，通过导出Pod和节点的状态反馈给REST系统；</li>
<li>etcd 信息存储，保存了整个集群的状态</li>
<li>flannel　IP地址的分配<br><img src="https://i.loli.net/2017/10/20/59e9a1d50897a.png" alt="tujie"><br>Cluster，即集群：虚拟机或者物理机的一组集合，运行着Kubernetes<ul>
<li>ETCD<ul>
<li>一个分布式强一致性的key&#x2F;value存储</li>
<li>可理解为一个存储k8s信息的数据库</li>
</ul>
</li>
<li>Node<ul>
<li>工作节点，运行Master节点交付的任务</li>
<li>能运行一个或多个Pods</li>
<li>运行的组件<ul>
<li>Kubelet<ul>
<li>管理容器的守护进程</li>
<li>管理Docker主机来启动容器的管理程序</li>
<li>定期从etcd获取分配到本机的pod信息，启动或停止容器</li>
<li>接收apiserver的HTTP请求，汇报pod的运行状态</li>
</ul>
</li>
<li>Proxy<ul>
<li>服务发现（IP寻址）</li>
<li>定期从etcd获取所有的service根据service信息创建代理</li>
<li>客户pod访问其他pod都经过proxy转发</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Master<ul>
<li>提供了集群统一视图的中心控制点</li>
<li>一个Master节点来控制多个Node节点</li>
<li>运行的组件<ul>
<li>API Server<ul>
<li>对操作对象的增删改查</li>
<li>提供RESTful K8s API接口</li>
<li>校验和配置Pod、Service和Replication Controller</li>
<li>统一管理集群系统的入口</li>
</ul>
</li>
<li>Scheduler<ul>
<li>资源调度</li>
<li>为新建的pod分配机器</li>
</ul>
</li>
<li>Controller-Manager<ul>
<li>容错处理</li>
<li>扩容、缩容</li>
<li>负责执行各种控制器</li>
<li>endpoint-controller<br>  定期关联service和pod(关联信息由endpoint对象维护)，保证service到pod的映射总是最新的</li>
<li>replication-controller<br>  定期关联replicationController和pod，保证定义的复制数量与实际运行pod的数量总是一致的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可操作对象</p>
<pre><code>* Pod：k8s上可创建、调度和管理的最小单位，是一个或一组拥有共享卷的容器集
* Replication Controller：管理着Pod的生命周期，建议创建Pod都是用rc，他会确保任何时刻Pod的数量都维持在一个特殊设定的值
* Service：基本的负载均衡器，为外部某提供一组Pod的一个稳定操作接口
</code></pre>
<p><a href="http://blog.csdn.net/qq1010885678/article/details/48719923">文档资料来自</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>BGP的工作原理</title>
    <url>/hexoblog/2017/09/12/BGP%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/20/59e999adbe5e3.png" alt="BGP"></p>
<p>在我们使用AWS提供的硬件VPN服务时，可以使用静态和动态的方式构建隧道。<br>静态的是指事先知道对方的公网IP，在两个IP之间写好静态的路由，构建一条加密的隧道<br>动态是指使用BGP协议来自动学习路由。</p>
<p><strong><code>BGP(Border Gateway Protocol)</code></strong><br>边界网关协议，TCP 179<br>BGP是一种在自治系统（AS）之间动态交换路由信息的路由协议。一个自治系统的经典定义是在一个管理机构控制之下的一组路由器，它使用IGP和普通度量值向其他自治系统转发报文。<br>在BGP中使用自治系统这个术语是为了强调这样一个事实：一个自治系统的管理对于其他自治系统而言是提供一个统一的内部选路计划，它为那些通过它可以到达的网络提供了一个一致的描述。BGP,边界网关协议，是自主网络系统中网关之间交换器路由信息的协议。边界网关协议常常应用于互联网的网关之间。路由表包含已知路由器的列表、路由器能够达到的地址以及到达每个路由器的路径的跳数。<br><strong><code>BGP报文的四种类型：</code></strong></p>
<ul>
<li>报文Open：打招呼“你好，跟我交个朋友吧！”</li>
<li>KeepAlive：我还活着呢，别不理我</li>
<li>Update：有新闻……</li>
<li>Notification：我不跟你玩了!</li>
</ul>
<p>BGP协议中消息的应用<br>通过TCP建立BGP连接时，发送open消息<br>连接建立后，如果有路由需要发送或路由变化时，发送UPDATE消息通告对端路由信息<br>稳定后此时要定时发送KEEPALIVE消息（60s）以保持BGP连接的有效性<br>当本地BGP在运行中发现错误时，要发送NOTIFICATION消息通告BGP对端</p>
<p><strong><code>BGP择路的13个规则</code></strong></p>
<ul>
<li>忽略下一跳不可达的路由</li>
<li>忽略不同步的IBGP路由</li>
<li>首选具有最大权重优先，思科私有。(local to router)</li>
<li>首选具有最大本地优先级优先。(global within AS)</li>
<li>首选具有始发本地的路由的路由器优先，(next hop&#x3D;0.0.0.0)</li>
<li>首选具有最短AS-PATH的路由。</li>
<li>首选具有最小的源码的路由，IGP〈EBP〈incomplete</li>
<li>当所有路由的AS号都相同的时候，首选MED最低的路由，在所有AS号码相同的时候比较MED</li>
<li>首选具有EBGP〉联盟EBGP&gt;IBGP</li>
<li>首选具有最近的IGP邻居路由器优先，metric</li>
<li>首选具有最老的路由优先（注意：现在这条基本不用）</li>
<li>首选具有最低ROUTER-ID的路由。(2个BGP地址不能建邻)</li>
<li>首选具有最低的neighbor的IP地址</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>网络协议</tag>
        <tag>bgp</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx和Apache负载均衡比较</title>
    <url>/hexoblog/2017/10/13/Nginx%E5%92%8CApache%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><img src="https://ooo.0o0.ooo/2017/10/30/59f6fa7fc3b66.png" alt="mahua"></p>
<span id="more"></span>
<h2 id="Apache与Nginx的优缺点比较-（同步阻塞与异步非阻塞的比较）"><a href="#Apache与Nginx的优缺点比较-（同步阻塞与异步非阻塞的比较）" class="headerlink" title="Apache与Nginx的优缺点比较 （同步阻塞与异步非阻塞的比较）"></a>Apache与Nginx的优缺点比较 （同步阻塞与异步非阻塞的比较）</h2><p>nginx相对于apache的优点：</p>
<ul>
<li>轻量级，同样起web 服务，比apache 占用更少的内存及资源 </li>
<li>抗并发，nginx 处理请求是异步非阻塞的，而apache 则是同步阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 ，适合静态请求和做反向代理服务器</li>
<li>高度模块化的设计，编写模块相对简单 </li>
<li>社区活跃，各种高性能模块出品迅速</li>
</ul>
<p>apache 相对于nginx 的优点： </p>
<ul>
<li>rewrite ，比nginx 的rewrite 强大，处理动态请求比较好 </li>
<li>模块超多，基本想到的都可以找到 </li>
<li>少bug ，nginx 的bug 相对较多 </li>
<li>稳定</li>
</ul>
<p>两者最核心的区别在于 apache 是同步多进程模型，同步阻塞模型，一个连接对应一个进程，对于动态请求支持比较好，而 nginx 是异步非阻塞模型，多个连接（万级别）可以对应一个进程，对于静态和反向请求支持比较好。</p>
<hr>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>同步与异步同步和异步关注的是消息通信机制 (synchronous communication&#x2F; asynchronous communication)所谓同步，就是在发出一个<strong>调用</strong>时，在没有得到结果之前，该<strong>调用</strong>就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由<strong>调用者</strong>主动等待这个<strong>调用</strong>的结果。而异步则是相反，<strong>调用</strong>在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在<strong>调用</strong>发出后，<strong>被调用者</strong>通过状态、通知来通知调用者，或通过回调函数处理这个调用。典型的异步编程模型比如Node.js</p>
<p>举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
<h2 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h2><p>阻塞与非阻塞阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态，阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>apache</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语法</title>
    <url>/hexoblog/2017/08/19/Python%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>#基本语法#</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP拥塞控制</title>
    <url>/hexoblog/2017/11/01/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p><img src="http://oytystujz.bkt.clouddn.com/17-11-6/17681942.jpg"></p>
<span id="more"></span>
<h2 id="TCP拥塞控制分为四个阶段"><a href="#TCP拥塞控制分为四个阶段" class="headerlink" title="TCP拥塞控制分为四个阶段"></a>TCP拥塞控制分为四个阶段</h2><p>分为主要的四个过程，即慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（Fast Retransmission）和快速回复（quick reply）</p>
<ul>
<li>慢启动阶段  为了避免路由资源德尔耗尽，在网络传输的开始阶段，建立一个新的网络连接不会一次性向网络发送大量的数据包，而是使用慢启动算法一步步的探测网络的可被利用带宽的大小，每收到惩恶ACK包，cwnd就加1。每一个慢启动算法的连接设置都有两个变量cwnd和ssthresh 。在网络连接最初建立起来时，拥塞窗口被初始化设置为一个数据包大小，实际发送窗口win的取值是拥塞窗口与接收端提供的反馈的窗口之间小者，即win&#x3D;win（cwnd，awnd）。拥塞窗口的数值会加倍在信源端接到接收端的应答（ACK帧），所以拥塞窗口在之后的变化过程中将按指数方式增长，因此网络传输的数据量按指数方式递增。其实慢启动阶段一点都不慢。</li>
<li>拥塞控制阶段  一般来说，网络认为拥塞发生时在发送端检测到重传定时器超时或者是收到了三次相同的应答时，然后整个过程进入拥塞避免过程。此时，将slow start threshold的值变成发生前次网络拥塞时的congestion window值的一半，网络中有数据的丢失因为网络中的拥塞是因为收到多次相同的应答，但是这个时候依然有数据包在传送，此时congestion window的值降低为原来的一半（即积式减少），整个传输过程进入拥塞避免过程，congestion window在每次收到一个应答时只是增加1&#x2F; congestion window个数据包，所以此时cwnd按照线性的关系增长；congestion window要被重新变为1当网络因为超时而发生拥塞，此时要重新开始慢启动的阶段，改变窗口值大小，另外网络这个时候由于超时的影响不再有从信源端到接受端的数据流了，之后当congestion window增长到大于slow start threshold时进入拥塞避免阶段，congestion window开始按照线性关系变化。</li>
<li>快速重传阶段  当网络发生拥塞时，因为信源端要等待一个网络响应超时的时间间隔，所以网络不能很快的对拥塞做出反应。发送端在接受到重复的应答时不能确定其产生的原因是众多原因中的哪个，是由于数据包丢弃造成或者是数据包失序造成的。一般来说假设，当发生数据包失序时，在接受端解决这个问题前，信源端只会收到一、两个重复的应答信号，如果接受端连续收到三个或者更多的重复的ACK信号，此时网络直到整个传输的过程中一个数据包由于拥塞被丢失了。在这种情况下发送端不需要等待一个超时间隔就重新传送那个可能丢失的数据包，这种传送数据包的方式为快速重传。</li>
<li>快速恢复阶段  拥塞窗口将减少为1当重新进入慢启动阶段，这种变化会严重降低网络的吞吐量。但是由于快速恢复算法，信源端将快速执行拥塞避免算法，这样就可以避免由于发送窗口数值过度变化而导致的网络性能网络以及平均吞吐量的下降。</li>
</ul>
<hr>
<h2 id="四种拥塞控制机制："><a href="#四种拥塞控制机制：" class="headerlink" title="四种拥塞控制机制："></a>四种拥塞控制机制：</h2><ul>
<li>TCP Tahoe<br>Tahoe具有TCP的基本结构，是早期的版本。<code>快速重传</code>的方法被添加在这个版本中。其快速重传重新发送数据包的重要依据是Duplicate ACK，例如传送端要是收到三个Duplicate ACK，改数据包被认为已经在网络传输的过程中遗失，不等待时间结束便立即重新发送。接着将slow start threshold的值设置为congestion window的一半 ,并将congestion window的值重新设置为1。</li>
<li>TCP Reno<br>在所以的TCP版本中，这个版本使用的最为广泛。Reno改变了Tahoe的某些算法，它比早期版本多了<code>快速恢复机制</code>。 Reno以快速恢复代替了 TCP Tahoe在重传遗失数据包后马上就进入慢启动过程。Reno在使用快速重传重新发送遗失的数据包后，会将slow start threshold以及congestion window的值都设置为之前检测到数据包丢失时congestion window值的一半。</li>
<li>TCP Newreno<br>Newreno是修改自Reno的版本。这个版本中主要修改了 Reno的快速恢复算法。Newreno在收到应答时，并不会马上结束快速恢复，相反，Newreno的发送端会持续地重新发送前一个应答之后的数据包，直到将所有遗失数据报都重新发送后，然后在此时结束快速恢复过程，所以Newreno的传送端在网络即使有很多的数据包遗失也不用等待超时结束就能更正网络传输的错误，减少大量数据包遗失对传输效果以及网络性能的影响。Newreno大约每一个接受回复时间可重送一个丢失的数据包，在快速恢复阶段，若允许的话，发送端链路的使用效率将会增加因为传输过程中不断有数据包传送。</li>
<li>TCP Vegas<br>Vegas与其他的Reno衍生版本不同之处在于它通过预想的结果和实际情形的比对来决定拥塞窗口的数值如何变化。有研究表明这个版本会比 Reno能得到更高的频带利用率。Vegas使用了三种方法来提高网络传输性能。<br>（1） <code>新的重传机制</code>  在Vegas中，为了能够及时检测出是否有数据包丢失并且立即重新发送新的数据包Vegas不再使用原来单一的重新传送的机制。一旦收到一个重复应答信号时，Vegas会检测接受应答时间是否大于超时的数值，如果检测出大于超时数值这判定为超时，此时不需要等待经过三个应答，Vegas就会直接重新发送此封包。另外，在丢失的数据包被重新发送，发送新的应答时，Vegas也会检测之前发送回来的的两个应答，从而来判定随后的封包此时是否超时，并重新发送丢失的数据包。<br>（2） <code>新的拥塞避免机制</code>  Reno的拥塞控制算法使用数据包丢失作为一种通知信号来显示网络是否发生了拥塞。Reno会不断的调整窗口的大小直到有新的数据包丢失，从而检测出来网络当时的可用频带宽度，并且通过这种方式来优化网络的传输性能。所以周期性丢包的问题时常发生在传统的Reno中，因此Vegas对于控制传送的速率，采用一种更加新颖的方式。<br>TCP通过观察接受回复时间的变化情况来控制congestion window的数值。Vegas根据预期传送速率和实际的网络速率的差值来调整congestion window的数值大小。若网络发生了拥塞，表示传送的速率过大，Vegas用来表征的差值也过大，因此要适当的降低congestion window的数值来减缓网络传送数据的速率，反之当网络的使用率过低则要加大congestion window的数值来增加传送的速率。<br>（3） <code>修改慢启动阶段</code>   相比较于TCP Reno，TCP Vegas希望不仅仅可以有效的使用可用的频带外，还要避免因为网络传输速率过快而发生的数据包丢失的情况。因此在慢启动的阶段为了可以检测到封包遗失以及有效的避免封包遗失，TCP Vegas修改了慢启动的算法来减缓congestion window的增加速度。在这个阶段，congestion window的值大约经过两个接受应答时间才会变为原来的二倍。Vegas会根据预期网络数据传送率和实际的网络传送传送率的差值来调整slow start threshold的数值，当TCP Vegas 检测到网络开始有队列产生是，Vegas就会通过慢启动阶段进入拥塞避免阶段。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>网络协议</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>article title</title>
    <url>/hexoblog/2017/08/12/article-title/</url>
    <content><![CDATA[<p>Welcome to dclarken’s page!<br>8.12 is my first day for writing!<br>First of all,<br>I want to say thank you to my best friends :<br>Dachang,Hongwei,Jingchang,Xidun,Yue,Yunhao<br>Best wishes to all of you!</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>freinds</tag>
      </tags>
  </entry>
  <entry>
    <title>dp-求数组连续最大和</title>
    <url>/hexoblog/2017/09/18/dp-%E6%B1%82%E6%95%B0%E7%BB%84%E8%BF%9E%E7%BB%AD%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<p>一个数组有 N 个元素，求连续子数组的最大和。<br>例如：[-1,2,1]，和最大的连续子数组为[2,1]，其和为 3<br>属于动态规划问题，从小到大一直找。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    nums=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> raw_input().split()]</span><br><span class="line">    <span class="comment">#nums=[-1,0,1]</span></span><br><span class="line">    <span class="built_in">print</span>(sum_s(nums))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_s</span>(<span class="params">nums</span>):</span><br><span class="line">    s_max=<span class="literal">None</span></span><br><span class="line">    s_sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> s_sum&gt;<span class="number">0</span>:</span><br><span class="line">            s_sum=s_sum+nums[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            s_sum=nums[i]</span><br><span class="line">        s_max=<span class="built_in">max</span>(s_max,s_sum)</span><br><span class="line">    <span class="keyword">return</span> s_max </span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>dp-求两个字符串的最大公共子序列</title>
    <url>/hexoblog/2017/09/16/dp-%E6%B1%82%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function </span><br><span class="line"><span class="comment">#将python3中的print函数调用，可以实现end=‘’不换行输出的功能</span></span><br><span class="line"><span class="keyword">import</span> math</span><br></pre></td></tr></table></figure>
<p>问题描述：<br>求出两个字符串最大公共子序列以及输出他的长度，基础动态规划题目</p>
<p>输入：<br>2017 11 02<br>02 11 2017<br>输出：<br>最大公共子序列</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#_*_coding: utf_8 _*_ </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">a,b</span>):</span><br><span class="line">    lena=<span class="built_in">len</span>(a)</span><br><span class="line">    lenb=<span class="built_in">len</span>(b)</span><br><span class="line">    c=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenb+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lena+<span class="number">1</span>)]</span><br><span class="line">    flag=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenb+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lena+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lena):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lenb):</span><br><span class="line">            <span class="keyword">if</span> a[i]==b[j]:</span><br><span class="line">                c[i+<span class="number">1</span>][j+<span class="number">1</span>]=c[i][j]+<span class="number">1</span></span><br><span class="line">                flag[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="string">&#x27;ok&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> c[i+<span class="number">1</span>][j]&gt;c[i][j+<span class="number">1</span>]:</span><br><span class="line">                c[i+<span class="number">1</span>][j+<span class="number">1</span>]=c[i+<span class="number">1</span>][j]</span><br><span class="line">                flag[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="string">&#x27;le&#x27;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c[i+<span class="number">1</span>][j+<span class="number">1</span>]=c[i][j+<span class="number">1</span>]</span><br><span class="line">                flag[i+<span class="number">1</span>][j+<span class="number">1</span>]=<span class="string">&#x27;up&#x27;</span></span><br><span class="line">    maxnum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,lena):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(lenb):</span><br><span class="line">            <span class="keyword">if</span> flag[-i][-j]==<span class="string">&#x27;ok&#x27;</span>:</span><br><span class="line">                count=c[-i][-j]</span><br><span class="line">                maxnum=<span class="built_in">max</span>(maxnum,<span class="built_in">int</span>(count))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> c,flag,maxnum</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printLcs</span>(<span class="params">flag,a,i,j</span>):</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> j==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> flag[i][j]==<span class="string">&#x27;ok&#x27;</span>:</span><br><span class="line">        printLcs(flag,a,i-<span class="number">1</span>,j-<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(a[i-<span class="number">1</span>],end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> flag[i][j]==<span class="string">&#x27;le&#x27;</span>:</span><br><span class="line">        printLcs(flag,a,i,j-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        printLcs(flag,a,i-<span class="number">1</span>,j) </span><br><span class="line">a=<span class="string">&#x27;2017 11 02&#x27;</span></span><br><span class="line">b=<span class="string">&#x27;02 11 2017&#x27;</span></span><br><span class="line">c,flag,count=lcs(a,b)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> c:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(j)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">printLcs(flag,a,<span class="built_in">len</span>(a),<span class="built_in">len</span>(b))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(count)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>dp-求给定数组中和大于积的次数</title>
    <url>/hexoblog/2017/09/17/dp-%E6%B1%82%E7%BB%99%E5%AE%9A%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%A7%AF%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>问题描述<br>一个袋子里面有n个球，每个球上面都有一个号码(拥有相同号码的球是无区别的)。如果一个袋子是幸运的当且仅当所有球的号码的和大于所有球的号码的积。<br>例如：如果袋子里面的球的号码是{1, 1, 2, 3}，这个袋子就是幸运的，因为1 + 1 + 2 + 3 &gt; 1 * 1 * 2 * 3<br>你可以适当从袋子里移除一些球(可以移除0个,但是别移除完)，要使移除后的袋子是幸运的。现在让你编程计算一下你可以获得的多少种不同的幸运的袋子。</p>
<p>输入：<br>球号数组<br>输出<br>种类</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isluck</span>(<span class="params">nums</span>): <span class="comment">#幸运袋子判断函数</span></span><br><span class="line">    <span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line">    mul=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="built_in">sum</span> +=i</span><br><span class="line">        mul *=i</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">sum</span>&gt;mul:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">composite</span>(<span class="params">array,Sum,multiply</span>): <span class="comment">#从小到大的规划过程</span></span><br><span class="line">    count=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(array)):</span><br><span class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> array[i]==array[i-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        Sum+=array[i]</span><br><span class="line">        multiply*=array[i]</span><br><span class="line">        <span class="keyword">if</span> Sum&gt;multiply:</span><br><span class="line">            count+=<span class="number">1</span>+composite(array[i+<span class="number">1</span>:], Sum, multiply) <span class="comment"># 当序列中的数值都比较大的时候能够满足要求，那数值小的也更加容易满足</span></span><br><span class="line">        <span class="keyword">elif</span> array[i]==<span class="number">1</span>:</span><br><span class="line">            count+=composite(array[i+<span class="number">1</span>:], Sum, multiply) <span class="comment"># 1为特殊情况，当为1的时候，和一定一直大于乘积，所以需要累加</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        Sum-=array[i] <span class="comment">#如果不满足，回退为上一状态</span></span><br><span class="line">        multiply/=array[i] </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n=raw_input()</span><br><span class="line">    array=raw_input().split()</span><br><span class="line">    array=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> array]</span><br><span class="line">    array.sort() <span class="comment">#首先对其从小到大排列</span></span><br><span class="line">    <span class="built_in">print</span> composite(array,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
        <category>dp</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown编辑器</title>
    <url>/hexoblog/2017/08/13/Markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/20/59e958907d2d2.jpg" alt="mahua"></p>
<span id="more"></span>
<p>像素选择500*300</p>
<h2 id="MaHua是什么"><a href="#MaHua是什么" class="headerlink" title="MaHua是什么?"></a>MaHua是什么?</h2><p>一个在线编辑markdown文档的编辑器</p>
<p>向Mac下优秀的markdown编辑器mou致敬</p>
<h2 id="MaHua有哪些功能？"><a href="#MaHua有哪些功能？" class="headerlink" title="MaHua有哪些功能？"></a>MaHua有哪些功能？</h2><ul>
<li>方便的<code>导入导出</code>功能<ul>
<li>直接把一个markdown的文本文件拖放到当前这个页面就可以了</li>
<li>导出为一个html格式的文件，样式一点也不会丢失</li>
</ul>
</li>
<li>编辑和预览<code>同步滚动</code>，所见即所得（右上角设置）</li>
<li><code>VIM快捷键</code>支持，方便vim党们快速的操作 （右上角设置）</li>
<li>强大的<code>自定义CSS</code>功能，方便定制自己的展示</li>
<li>有数量也有质量的<code>主题</code>,编辑器和预览区域</li>
<li>完美兼容<code>Github</code>的markdown语法</li>
<li>预览区域<code>代码高亮</code></li>
<li>所有选项自动记忆</li>
</ul>
<h2 id="有问题反馈"><a href="#有问题反馈" class="headerlink" title="有问题反馈"></a>有问题反馈</h2><p>在使用中有任何问题，欢迎反馈给作者，可以用以下联系方式跟作者交流</p>
<ul>
<li>邮件(dev.hubo#gmail.com, 把#换成@)</li>
<li>QQ: 287759234</li>
<li>weibo: <a href="http://weibo.com/ihubo">@草依山</a></li>
<li>twitter: <a href="http://twitter.com/ihubo">@ihubo</a></li>
</ul>
<h2 id="感激"><a href="#感激" class="headerlink" title="感激"></a>感激</h2><p>感谢以下的项目,排名不分先后</p>
<ul>
<li><a href="http://mouapp.com/">mou</a> </li>
<li><a href="http://ace.ajax.org/">ace</a></li>
<li><a href="http://jquery.com/">jquery</a></li>
</ul>
<h2 id="表格实现"><a href="#表格实现" class="headerlink" title="表格实现"></a>表格实现</h2><table>
<thead>
<tr>
<th>Namespace</th>
<th>系统调用参数</th>
<th>隔离内容</th>
</tr>
</thead>
<tbody><tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>主机名与域名</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>信号量、消息队列和共享内存</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>进程编号</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>网络设备、网络栈、端口等等</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>挂载点（文件系统）</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>用户和用户组</td>
</tr>
</tbody></table>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="variable language_">self</span>.name=[]</span><br><span class="line">    <span class="variable language_">self</span>.age=[] </span><br></pre></td></tr></table></figure>
<h1 id="该文可以用来便于查看markdown的语法规则"><a href="#该文可以用来便于查看markdown的语法规则" class="headerlink" title="该文可以用来便于查看markdown的语法规则"></a>该文可以用来便于查看markdown的语法规则</h1><p>感谢作者</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Markdown</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议详细解析</title>
    <url>/hexoblog/2017/10/13/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/11/01/59f9532f55dc8.png" alt="mahua"></p>
<span id="more"></span>

<p><a href="http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.html">详细解析文档</a></p>
<h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><p><a href="http://www.cnblogs.com/ranyonsue/p/5984001.html">工作原理</a></p>
<p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求&#x2F;响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>
<p><strong>以下是 HTTP 请求&#x2F;响应的步骤：</strong></p>
<ul>
<li>客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.oakcms.cn./">http://www.oakcms.cn。</a></li>
<li>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</li>
<li>服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</li>
<li>释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</li>
<li>客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</li>
</ul>
<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>
<ul>
<li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li>
<li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li>
<li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li>
<li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li>
<li>释放 TCP连接;</li>
<li>浏览器将该 html 文本并显示内容;</li>
</ul>
<p><strong>HTTP协议的主要特点可概括如下：</strong></p>
<ul>
<li>支持客户&#x2F;服务器模式。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了Cookie机制来维护状态.</li>
</ul>
<hr>
<h2 id="HTTP协议详解之URL篇"><a href="#HTTP协议详解之URL篇" class="headerlink" title="HTTP协议详解之URL篇"></a>HTTP协议详解之URL篇</h2><p>http（超文本传输协议）是一个基于请求与响应模式的、无状态的、面向连接、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。</p>
<p>HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">schema://host[:port#]/path/.../[?query-string][#anchor]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>scheme               指定低层使用的协议(例如：http, https, ftp)<br>host                   HTTP服务器的IP地址或者域名<br>port#                 HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/">http://www.cnblogs.com:8080/</a><br>path                   访问资源的路径<br>query-string       发送给http服务器的数据<br>anchor-             锚</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">http://www.mywebsite.com/sj/test/test.aspx?name=sviergn&amp;x=true#stuff</span><br><span class="line"></span><br><span class="line"><span class="attribute">Schema</span><span class="punctuation">: </span>                http</span><br><span class="line"><span class="attribute">host</span><span class="punctuation">: </span>                  www.mywebsite.com</span><br><span class="line"><span class="attribute">path</span><span class="punctuation">: </span>                  /sj/test/test.aspx</span><br><span class="line">Query String:           name=sviergn&amp;x=true</span><br><span class="line"><span class="attribute">Anchor</span><span class="punctuation">: </span>                stuff</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="HTTP协议详解之请求篇"><a href="#HTTP协议详解之请求篇" class="headerlink" title="HTTP协议详解之请求篇"></a>HTTP协议详解之请求篇</h2><p>http请求由三部分组成，分别是：请求行、消息报头、请求正文、空行</p>
<p>1.请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF<br>其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</p>
<p>请求方法（所有方法全为大写）有多种，各个方法的解释如下：<br>GET     请求获取Request-URI所标识的资源<br>POST    在Request-URI所标识的资源后附加新的数据<br>HEAD    请求获取由Request-URI所标识的资源的响应消息报头<br>PUT     请求服务器存储一个资源，并用Request-URI作为其标识<br>DELETE  请求服务器删除Request-URI所标识的资源<br>TRACE   请求服务器回送收到的请求信息，主要用于测试或诊断<br>CONNECT 保留将来使用<br>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求</p>
<p><code>GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</code><br><strong>我们看看GET和POST的区别</strong></p>
<ul>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name&#x3D;test1&amp;id&#x3D;123456.  POST方法是把提交的数据放在HTTP包的Body中.</li>
<li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</li>
<li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</li>
<li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</li>
</ul>
<p>应用举例：<br>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET &#x2F;form.html HTTP&#x2F;1.1 (CRLF)</p>
<p>POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">eg：POST /reg.jsp HTTP/ (CRLF)</span><br><span class="line">Accept:image/gif,image/x-xbit,... (CRLF)</span><br><span class="line">...</span><br><span class="line">HOST:www.guet.edu.cn (CRLF)</span><br><span class="line">Content-Length:22 (CRLF)</span><br><span class="line">Connection:Keep-Alive (CRLF)</span><br><span class="line">Cache-Control:no-cache (CRLF)</span><br><span class="line">(CRLF)         //该CRLF表示消息报头已经结束，在此之前为消息报头（消息报头和正文之间的空行）</span><br><span class="line">user=jeffrey&amp;pwd=1234  //此行以下为提交的数据</span><br></pre></td></tr></table></figure>

<p>HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。<br>2.请求报头后述<br>3.请求正文(略) </p>
<hr>
<h2 id="HTTP协议详解之响应篇"><a href="#HTTP协议详解之响应篇" class="headerlink" title="HTTP协议详解之响应篇"></a>HTTP协议详解之响应篇</h2><p>在接收和解释请求消息后，服务器返回一个HTTP响应消息。</p>
<p>HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文</p>
<p>1.状态行格式如下：<br>HTTP-Version Status-Code Reason-Phrase CRLF<br>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。<br>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求<br>常见状态代码、状态描述、说明：<br>200 OK      &#x2F;&#x2F;客户端请求成功<br>400 Bad Request  &#x2F;&#x2F;客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized &#x2F;&#x2F;请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden  &#x2F;&#x2F;服务器收到请求，但是拒绝提供服务<br>404 Not Found  &#x2F;&#x2F;请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error &#x2F;&#x2F;服务器发生不可预期的错误<br>503 Server Unavailable  &#x2F;&#x2F;服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br>eg：HTTP&#x2F;1.1 200 OK （CRLF）</p>
<p>2.响应报头后述</p>
<p>3.响应正文就是服务器返回的资源的内容</p>
<hr>
<h2 id="HTTP协议详解之消息报头篇"><a href="#HTTP协议详解之消息报头篇" class="headerlink" title="HTTP协议详解之消息报头篇"></a>HTTP协议详解之消息报头篇</h2><p>HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。</p>
<p>HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。<br>每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。</p>
<p><strong>1、普通报头</strong><br>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。<br>eg：</p>
<ul>
<li><p>Cache-Control   用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。<br>请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;<br>响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.<br>eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(“Cache-Control”,”no-cache”);<br>&#x2F;&#x2F;response.setHeader(“Pragma”,”no-cache”);作用相当于上述代码，通常两者&#x2F;&#x2F;合用<br>这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache</p>
</li>
<li><p>Date普通报头域表示消息产生的日期和时间</p>
</li>
<li><p>Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接</p>
</li>
</ul>
<p><strong>2、请求报头 Client头域</strong><br>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。<br>常用的请求报头</p>
<ul>
<li>Accept<br>Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image&#x2F;gif，表明客户端希望接受GIF图象格式的资源；Accept：text&#x2F;html，表明客户端希望接受html文本。</li>
<li>Accept-Charset<br>Accept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。</li>
<li>Accept-Encoding<br>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。</li>
<li>Accept-Language<br>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。</li>
<li>Authorization<br>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。</li>
<li>Host（发送请求时，该报头域是必需的）<br>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：<br>我们在浏览器中输入：<a href="http://www.guet.edu.cn/index.html">http://www.guet.edu.cn/index.html</a><br>浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br>Host：<a href="http://www.guet.edu.cn/">www.guet.edu.cn</a><br>此处使用缺省端口号80，若指定了端口号，则变成：Host：<a href="http://www.guet.edu.cn:指定端口号">www.guet.edu.cn:指定端口号</a></li>
<li>User-Agent<br>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。<br>请求报头举例：</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET /form.html HTTP/1.1 (CRLF)</span><br><span class="line">Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)</span><br><span class="line">Accept-Language:zh-cn (CRLF)</span><br><span class="line">Accept-Encoding:gzip,deflate (CRLF)</span><br><span class="line">If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)</span><br><span class="line">If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)</span><br><span class="line">User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)</span><br><span class="line">Host:www.guet.edu.cn (CRLF)</span><br><span class="line">Connection:Keep-Alive (CRLF)</span><br><span class="line">(CRLF)</span><br></pre></td></tr></table></figure>


<p><strong>3、响应报头</strong><br>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。<br>常用的响应报头</p>
<ul>
<li>Location<br>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。</li>
<li>Server<br>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是<br>Server响应报头域的一个例子：<br>Server：Apache-Coyote&#x2F;1.1</li>
<li>WWW-Authenticate<br>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。<br>eg：WWW-Authenticate:Basic realm&#x3D;”Basic Auth Test!”  &#x2F;&#x2F;可以看出服务器对请求资源采用的是基本验证机制。</li>
</ul>
<p><strong>4、实体报头 Entity头域</strong><br>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。<br>常用的实体报头</p>
<ul>
<li>Content-Encoding<br>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip</li>
<li>Content-Language<br>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读<br>者。eg：Content-Language:da</li>
<li>Content-Length<br>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。</li>
<li>Content-Type<br>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：<br>Content-Type:text&#x2F;html;charset&#x3D;ISO-8859-1<br>Content-Type:text&#x2F;html;charset&#x3D;GB2312</li>
<li>Last-Modified<br>Last-Modified实体报头域用于指示资源的最后修改日期和时间。</li>
<li>Expires<br>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT<br>HTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”);</li>
</ul>
<p><strong>利用telnet观察http协议的通讯过程</strong></p>
<p>实验目的及原理：<br>利用MS的telnet工具，通过手动输入http请求信息的方式，向服务器发出请求，服务器接收、解释和接受请求后，会返回一个响应，该响应会在telnet窗口上显示出来，从而从感性上加深对http协议的通讯过程的认识。</p>
<p>实验步骤：</p>
<p>1、打开telnet<br>1.1 打开telnet<br>运行–&gt;cmd–&gt;telnet</p>
<p>1.2 打开telnet回显功能</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> localecho</span><br></pre></td></tr></table></figure>

<p>2、连接服务器并发送请求<br>2.1 </p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">open www.guet.edu.cn 80  //注意端口号不能省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEAD</span> <span class="string">/index.asp</span> <span class="meta">HTTP/1.0</span></span><br><span class="line">Host:www.guet.edu.cn</span><br><span class="line">    </span><br><span class="line">/*我们可以变换请求方法,请求桂林电子主页内容,输入消息如下*/</span><br><span class="line">open www.guet.edu.cn 80 </span><br><span class="line">   </span><br><span class="line">GET /index.asp HTTP/1.0  //请求资源的内容</span><br><span class="line">Host:www.guet.edu.cn  </span><br></pre></td></tr></table></figure>

<p>2.2 </p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">open www.sina.com.cn 80  //在命令提示符号下直接输入telnet www.sina.com.cn 80</span><br><span class="line"><span class="keyword">HEAD</span> <span class="string">/index.asp</span> <span class="meta">HTTP/1.0</span></span><br><span class="line">Host:www.sina.com.cn</span><br></pre></td></tr></table></figure>

<p>3 实验结果：</p>
<p>3.1 请求信息2.1得到的响应是:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK                                              //请求成功</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Microsoft-IIS/5.0                                    //web服务器</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Thu,08 Mar 200707:17:51 GMT</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive                                 </span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>23330</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Expries</span><span class="punctuation">: </span>Thu,08 Mar 2007 07:16:51 GMT</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/</span><br><span class="line"><span class="attribute">Cache-control</span><span class="punctuation">: </span>private</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;资源内容省略</p>
<p>3.2 请求信息2.2得到的响应是:</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">404</span> Not Found       //请求失败</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Thu, 08 Mar 2007 07:50:50 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/2.0.54 &lt;Unix&gt;</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Thu, 30 Nov 2006 11:35:41 GMT</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;6277a-415-e7c76980&quot;</span><br><span class="line"><span class="attribute">Accept-Ranges</span><span class="punctuation">: </span>bytes</span><br><span class="line"><span class="attribute">X-Powered-By</span><span class="punctuation">: </span>mod_xlayout_jh/0.0.1vhs.markII.remix</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">X-Cache</span><span class="punctuation">: </span>MISS from zjm152-78.sina.com.cn</span><br><span class="line"><span class="attribute">Via</span><span class="punctuation">: </span>1.0 zjm152-78.sina.com.cn:80&lt;squid/2.6.STABLES-20061207&gt;</span><br><span class="line"><span class="attribute">X-Cache</span><span class="punctuation">: </span>MISS from th-143.sina.com.cn</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br></pre></td></tr></table></figure>

<p>失去了跟主机的连接</p>
<p>按任意键继续…</p>
<hr>
<h2 id="HTTP协议相关技术补充"><a href="#HTTP协议相关技术补充" class="headerlink" title="HTTP协议相关技术补充"></a>HTTP协议相关技术补充</h2><ul>
<li><p>基础：<br>  高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等<br>中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)，一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一 个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。<br>  代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处 理没有被用户代理完成的请求。<br>网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。<br>网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。<br>  通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继 的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p>
</li>
<li><p>协议分析的优势—HTTP分析器检测网络攻击<br>以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。<br>HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定</p>
</li>
<li><p>HTTP协议Content Lenth限制漏洞导致拒绝服务攻击<br>使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。</p>
</li>
<li><p>利用HTTP协议的特性进行拒绝服务攻击的一些构思<br>服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。<br>而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。<br>19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务<br>方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。</p>
</li>
<li><p>Http指纹识别技术<br>Http指纹识别的原理大致上也是相同的：记录不同服务器对Http协议执行中的微小差别进行识别.Http指纹识别比TCP&#x2F;IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP&#x2F;IP堆栈的行为 需要对核心层进行修改,所以就容易识别.<br>  要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。<br>常用测试请求：</p>
<ul>
<li>HEAD&#x2F;Http&#x2F;1.0发送基本的Http请求</li>
<li>DELETE&#x2F;Http&#x2F;1.0发送那些不被允许的请求,比如Delete请求</li>
<li>GET&#x2F;Http&#x2F;3.0发送一个非法版本的Http协议请求</li>
<li>GET&#x2F;JUNK&#x2F;1.0发送一个不正确规格的Http协议请求</li>
</ul>
</li>
</ul>
<p>Http指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术,能很有效的确定Http服务器的类型.它可以被用来收集和分析不同Http服务器产生的签名。</p>
<ul>
<li>其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>网络协议</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>http状态返回码</title>
    <url>/hexoblog/2017/10/22/http%E7%8A%B6%E6%80%81%E8%BF%94%E5%9B%9E%E7%A0%81/</url>
    <content><![CDATA[<p><img src="http://oytystujz.bkt.clouddn.com/17-11-3/56605452.jpg" alt="mahua"></p>
<span id="more"></span>

<p>状态代码 状态信息 代码含义</p>
<h2 id="1xx：指示信息–表示请求已接收，继续处理"><a href="#1xx：指示信息–表示请求已接收，继续处理" class="headerlink" title="1xx：指示信息–表示请求已接收，继续处理"></a>1xx：指示信息–表示请求已接收，继续处理</h2><p>100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。</p>
<p>101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议</p>
<hr>
<h2 id="2xx：成功–表示请求已被成功接收、理解、接受"><a href="#2xx：成功–表示请求已被成功接收、理解、接受" class="headerlink" title="2xx：成功–表示请求已被成功接收、理解、接受"></a>2xx：成功–表示请求已被成功接收、理解、接受</h2><p>200 OK 一切正常，对GET和POST请求的应答文档跟在后面。</p>
<p>201 Created 服务器已经创建了文档，Location头给出了它的URL。</p>
<p>202 Accepted 已经接受请求，但处理尚未完成。</p>
<p>203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝</p>
<p>204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</p>
<p>205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容</p>
<p>206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它。</p>
<hr>
<h2 id="3xx：重定向–要完成请求必须进行更进一步的操作"><a href="#3xx：重定向–要完成请求必须进行更进一步的操作" class="headerlink" title="3xx：重定向–要完成请求必须进行更进一步的操作"></a>3xx：重定向–要完成请求必须进行更进一步的操作</h2><p>300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。</p>
<p>301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</p>
<p>302 Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved”</p>
<p>303 See Other 类似于301&#x2F;302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取</p>
<p>304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</p>
<p>305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取</p>
<p>307 Temporary Redirect 和302 （Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是</p>
<p>303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。</p>
<hr>
<h2 id="4xx：客户端错误–请求有语法错误或请求无法实现"><a href="#4xx：客户端错误–请求有语法错误或请求无法实现" class="headerlink" title="4xx：客户端错误–请求有语法错误或请求无法实现"></a>4xx：客户端错误–请求有语法错误或请求无法实现</h2><p>400 Bad Request 请求出现语法错误。</p>
<p>401 Unauthorized 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字&#x2F;密码对话框，然后在填写合适的Authorization头后再次发出请求。</p>
<p>403 Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。</p>
<p>404 Not Found 无法找到指定位置的资源。这也是一个常用的应答。</p>
<p>405 Method Not</p>
<p>Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。</p>
<p>406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容</p>
<p>407 Proxy 类似于401，表示客户必须先经过代理服务器的授权。</p>
<p>408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。</p>
<p>409 Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。</p>
<p>410 Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。</p>
<p>411 Length Require 服务器不能处理请求，除非客户发送一个Content-Length头。</p>
<p>412 Precondition Failed 请求头中指定的一些前提条件失败</p>
<p>413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头</p>
<p>414 Request URI Too Long URI太长 。</p>
<p>416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。</p>
<hr>
<h2 id="5xx：服务器端错误–服务器未能实现合法的请求"><a href="#5xx：服务器端错误–服务器未能实现合法的请求" class="headerlink" title="5xx：服务器端错误–服务器未能实现合法的请求"></a>5xx：服务器端错误–服务器未能实现合法的请求</h2><p>500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。</p>
<p>501 Not Implemented 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。</p>
<p>502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</p>
<p>503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头。</p>
<p>504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。</p>
<p>505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>网络协议</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>jdk+eclipse+python环境搭建</title>
    <url>/hexoblog/2017/08/15/jdk+eclipse+python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>jdk下载：（java环境配置）<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">jdk下载地址</a><br>环境变量配置<br>首先设置JAVA_HOME,点击新建，变量名：JAVA_HOME,变量值：D:\java\jdk1.7.0,即jdk安装的路径。<br>设置CLASSPATH属性，变量名：CLASSPATH，变量值：.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;此时需要注意的是最前有.;，不能忘记，%JAVA_HOME%代表D:\java\jdk1.7.0此路径。<br>设置path属性，变量名：path，变量值：%java_home%\bin;%java_home%\jre\bin;，此属性一般都是有的，只需添加即可，注意分号的问题。<br>在cmd中输入命令java检测安装是成功<br>ps：%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;环境变量原本的文件内容表示的dos系统下cmd的解释器，在环境变量配置时，定义的环境变量文件名不区分大小写path&#x3D;PATH。<br>eclipse：<br><a href="http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/heliossr1/">eclipse下载地址</a><br>选择的下载版本为一个zip而不是官网的exe文件，官网的文件还需要后续联网下载，网络不稳定容易失败，zip文件解压缩之后既可以使用。<br>python插件：<br>1.<br>打开eclipse——Help——add-PyDev-<a href="http://pydev.org/updates%E2%80%94%E2%80%94PyDev%E2%80%94%E2%80%94PyDev">http://pydev.org/updates——PyDev——PyDev</a> for eclipse——下一步——重启——建立Python工程<br>上述过程同样需要上境外网络，连接VPN实施。<br>或者参考：<br>2.<br><a href="https://jingyan.baidu.com/article/cd4c2979101f02756f6e6064.html">python插件下载地址</a><br><a href="http://sourceforge.net/projects/pydev/files/pydev/PyDev%204.1.0/">pyDev包下载地址</a>下载PyDev 4.1.0.zip包，<br>把压缩包里面的plugins中的文件解压到Eclipse安装目录下plugins文件夹中，压缩包里面features中的文件目录也是同样操作。之后重启Eclipse。<br>检查是否已经正确安装pydev：打开Eclipse–&gt;Windows–&gt;preferences就能找到Pydev。<br>配置解释器。官网下载Python27或者Python34<br>选择Window &gt; Preferences &gt; Pydev &gt; Python Interpreter&gt;New ，继续配置解释器：Python安装在F:\Python27 路径下。单击 New，进入对话框。Interpreter Name可以随便命名，Interpreter Executable选择Python解释器python.exe，在安装文件夹下查找。而后下一步下一步。<br>建立Python工程：<br>工程建立：file-new-project-PyDev-PyDev Project-命名-finish<br>文件建立：项目名右键-new-PyDev Module（.py文件）-编写-运行Python Run</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx和LVS负载均衡对比</title>
    <url>/hexoblog/2017/11/02/nginx%E5%92%8CLVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p><img src="http://oytystujz.bkt.clouddn.com/17-11-3/417270.jpg"></p>
<span id="more"></span>

<p>Nginx&#x2F;LVS&#x2F;HAProxy是目前使用最广泛的三种负载均衡软件。 </p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx的优点是：</p>
<ul>
<li>1、工作在网络的7层之上，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。 </li>
<li>2、Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大；</li>
<li>3、Nginx安装和配置比较简单，测试起来比较方便，它基本能把错误用日志打印出来。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。 </li>
<li>4、可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。  </li>
<li>5、Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。  </li>
<li>6、Nginx不仅仅是一款优秀的负载均衡器&#x2F;反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。  </li>
<li>7、Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。  </li>
<li>8、Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有lighttpd了，不过lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。  </li>
<li>9、Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</li>
</ul>
<h2 id="LVS："><a href="#LVS：" class="headerlink" title="LVS："></a>LVS：</h2><p>使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。<br>LVS的优点是：</p>
<ul>
<li>1、抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特<br>点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。</li>
<li>2、配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。 </li>
<li>3、工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS&#x2F;DR+Keepalived。</li>
<li>4、无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会收到大流量的影响。  </li>
<li>5、应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</li>
</ul>
<h2 id="Nginx和LVS对比的："><a href="#Nginx和LVS对比的：" class="headerlink" title="Nginx和LVS对比的："></a>Nginx和LVS对比的：</h2><ul>
<li>1、Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。 </li>
<li>2、Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。  </li>
<li>3、Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。  </li>
<li>4、Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。 </li>
<li>5、Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。 </li>
<li>6、Nginx对请求的异步处理可以帮助节点服务器减轻负载，（也可以作为nginx和Apache在做web服务器时的比较）假如使用apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大 量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。</li>
<li>7、Nginx能支持http、https和email，LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>负载均衡</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>sort用法</title>
    <url>/hexoblog/2017/09/17/sort%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><a href="http://www.cnblogs.com/sunny3312/archive/2017/01/07/6260472.html">Python中的sort()方法使用基础文档：</a><br>格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(iterable[, cmp[, key[, reverse]]])</span><br><span class="line">iterable.sort(cmp[, key[, reverse]])</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<ul>
<li>iterable指定要排序的list或者iterable，不用多说；</li>
<li>cmp为函数，指定排序时进行比较的函数，可以指定一个函数或者lambda函数，如：<br>students为类对象的list，没个成员有三个域，用sorted进行比较时可以自己定cmp函数，例如这里要通过比较第三个数据成员来排序，代码可以这样写：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">students = [(<span class="string">&#x27;john&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">15</span>), (<span class="string">&#x27;jane&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">12</span>), (<span class="string">&#x27;dave&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">10</span>)]</span><br><span class="line"><span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> student : student[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li>key为函数，指定取待排序元素的哪一项进行排序，函数用上面的例子来说明，代码如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(students, key=<span class="keyword">lambda</span> student : student[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>key指定的lambda函数功能是去元素student的第三个域（即：student[2]），因此sorted排序时，会以students所有元素的第三个域来进行排序。</p>
<p>reverse实现降序排序，需要提供一个布尔值，默认为False（升序排列）。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/hexoblog/2017/11/02/test/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/20/59e958907d2d2.jpg" alt="mahua"><br>test for add and push</p>
<span id="more"></span>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>time模块</title>
    <url>/hexoblog/2017/10/12/time%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/11/01/59f9890e94a1e.jpg" alt="mahua"></p>
<span id="more"></span>
<p>Python时间模块之Time模块解析<br><a href="http://blog.csdn.net/SeeTheWorld518/article/details/48314501">文章转载来源</a><br>time模块。<br>在开始前，先说明几点：</p>
<ul>
<li>在Python中，通常有这几种方式表示时间：时间戳、格式化的时间字符串、元组（struct_time 共九种元素）。由于Python的time模块主要是调用C库实现的，所以在不同的平台可能会有所不同。</li>
<li>时间戳（timestamp）的方式：时间戳表示是从1970年1月1号 00:00:00开始到现在按秒计算的偏移量。查看一下type(time.time())的返回值类型，可以看出是float类型。返回时间戳的函数主要有time()、clock()等。</li>
<li>UTC（世界协调时），就是格林威治天文时间，也是世界标准时间。在中国为UTC+8。DST夏令时。</li>
<li>元组方式：struct_time元组共有9个元素，返回struct_time的函数主要有gmtime()，localtime()，strptime()。</li>
</ul>
<h2 id="time-localtime-获取当前的时间"><a href="#time-localtime-获取当前的时间" class="headerlink" title="time.localtime()获取当前的时间"></a>time.localtime()获取当前的时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">ls = time.localtime() 获取当前的时间，其生成的ls的数据结构为具有<span class="number">9</span>个元素的元组</span><br><span class="line">time.struct_time(tm_year=<span class="number">2015</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">24</span>, tm_hour=<span class="number">9</span>, tm_min=<span class="number">39</span>, tm_sec=<span class="number">38</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">236</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line">tm_year ：年</span><br><span class="line">tm_mon ：月（<span class="number">1</span>-<span class="number">12</span>）</span><br><span class="line">tm_mday ：日（<span class="number">1</span>-<span class="number">31</span>）</span><br><span class="line">tm_hour ：时（<span class="number">0</span>-<span class="number">23</span>）</span><br><span class="line">tm_min ：分（<span class="number">0</span>-<span class="number">59</span>）</span><br><span class="line">tm_sec ：秒（<span class="number">0</span>-<span class="number">59</span>）</span><br><span class="line">tm_wday ：星期几（<span class="number">0</span>-<span class="number">6</span>,<span class="number">0</span>表示周日）</span><br><span class="line">tm_yday ：一年中的第几天（<span class="number">1</span>-<span class="number">366</span>）</span><br><span class="line">tm_isdst ：是否是夏令时（默认为-<span class="number">1</span>）</span><br></pre></td></tr></table></figure>

<p>使用元组索引获取对应项的值，或者是使用成员符号调用。<br>调用年份的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls[<span class="number">0</span>]</span><br><span class="line"><span class="number">2015</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls.tm_year</span><br><span class="line"><span class="number">2015</span></span><br><span class="line">time.time()：返回当前时间的时间戳</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.time()</span><br><span class="line"><span class="number">1440337405.85</span></span><br><span class="line"><span class="comment">#对时间戳取整</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(time.time())</span><br><span class="line"><span class="number">1440746424</span></span><br></pre></td></tr></table></figure>

<h2 id="time-mktime-t-：将一个struct-time转化为时间戳"><a href="#time-mktime-t-：将一个struct-time转化为时间戳" class="headerlink" title="time.mktime(t)：将一个struct_time转化为时间戳"></a>time.mktime(t)：将一个struct_time转化为时间戳</h2><p>time.mktime() 函数执行与gmtime(), localtime()相反的操作，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.mktime(time.localtime())</span><br><span class="line"><span class="number">1440338541.0</span></span><br></pre></td></tr></table></figure>

<h2 id="time-sleep-secs-：线程推迟指定的时间运行"><a href="#time-sleep-secs-：线程推迟指定的时间运行" class="headerlink" title="time.sleep(secs)：线程推迟指定的时间运行"></a>time.sleep(secs)：线程推迟指定的时间运行</h2><p>secs表示线程睡眠指定时间，单位为妙。<br>time.clock()<br>函数以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。在不同的系统上含义不同。在NUix系统上，它返回的是“进程时间”，它是用妙表示的浮点数（时间戳）。而在Windows中，第一次调用，返回的是进程运行时实际时间。而第二次之后的调用是自第一次调用以后到现在的运行时间。<br>返回值<br>该函数有两个功能：</p>
<p>（1）在第一次调用的时候，返回的是程序运行的实际时间；<br>（2）第二次之后的调用，返回的是自第一次调用后,到这次调用的时间间隔在win32系统下，这个函数返回的是真实时间（wall time），而在Unix&#x2F;Linux下返回的是CPU时间。</p>
<h2 id="time-asctime-t"><a href="#time-asctime-t" class="headerlink" title="time.asctime( [t] )"></a>time.asctime( [t] )</h2><p>把一个表示时间的元组或者struct_time表示为 ‘Sun Aug 23 14:31:59 2015’ 这种形式。如果没有给参数，会将time.localtime()作为参数传入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.asctime(time.gmtime())</span><br><span class="line"><span class="string">&#x27;Sun Aug 23 14:31:59 2015&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="time-ctime-secs"><a href="#time-ctime-secs" class="headerlink" title="time.ctime([secs])"></a>time.ctime([secs])</h2><p>把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果为指定参数，将会默认使用time.time()作为参数。它的作用相当于time.asctime(time.localtime(secs)) </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.ctime(<span class="number">1440338541.0</span>)</span><br><span class="line"><span class="string">&#x27;Sun Aug 23 22:02:21 2015&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="time-strftime-format-t"><a href="#time-strftime-format-t" class="headerlink" title="time.strftime( format [, t] )"></a>time.strftime( format [, t] )</h2><p>返回字符串表示的当地时间。<br>把一个代表时间的元组或者struct_time（如由time.localtime()和time.gmtime()返回）转化为格式化的时间字符串，格式由参数format决定。如果未指定，将传入time.localtime()。如果元组中任何一个元素越界，就会抛出ValueError的异常。函数返回的是一个可读表示的本地时间的字符串。<br>参数：<br>format：格式化字符串<br>t ：可选的参数是一个struct_time对象<br>时间字符串支持的格式符号：（区分大小写）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%a  本地星期名称的简写（如星期四为Thu）      </span><br><span class="line">%A  本地星期名称的全称（如星期四为Thursday）      </span><br><span class="line">%b  本地月份名称的简写（如八月份为agu）    </span><br><span class="line">%B  本地月份名称的全称（如八月份为august）       </span><br><span class="line">%c  本地相应的日期和时间的字符串表示（如：<span class="number">15</span>/08/<span class="number">27</span> <span class="number">10</span>:<span class="number">20</span>:06）       </span><br><span class="line">%d  一个月中的第几天（01 - <span class="number">31</span>）  </span><br><span class="line">%f  微妙（范围<span class="number">0.999999</span>）    </span><br><span class="line">%H  一天中的第几个小时（<span class="number">24</span>小时制，<span class="number">00</span> - <span class="number">23</span>）       </span><br><span class="line">%I  第几个小时（<span class="number">12</span>小时制，<span class="number">0</span> - <span class="number">11</span>）       </span><br><span class="line">%j  一年中的第几天（001 - <span class="number">366</span>）     </span><br><span class="line">%m  月份（01 - <span class="number">12</span>）    </span><br><span class="line">%M  分钟数（<span class="number">00</span> - <span class="number">59</span>）       </span><br><span class="line">%p  本地am或者pm的相应符      </span><br><span class="line">%S  秒（<span class="number">00</span> - <span class="number">61</span>）    </span><br><span class="line">%U  一年中的星期数。（<span class="number">00</span> - <span class="number">53</span>星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第<span class="number">0</span>周。     </span><br><span class="line">%w  一个星期中的第几天（<span class="number">0</span> - <span class="number">6</span>，<span class="number">0</span>是星期天）    </span><br><span class="line">%W  和%U基本相同，不同的是%W以星期一为一个星期的开始。    </span><br><span class="line">%x  本地相应日期字符串（如<span class="number">15</span>/08/01）     </span><br><span class="line">%X  本地相应时间字符串（如08:08:<span class="number">10</span>）     </span><br><span class="line">%y  去掉世纪的年份（<span class="number">00</span> - <span class="number">99</span>）两个数字表示的年份       </span><br><span class="line">%Y  完整的年份（<span class="number">4</span>个数字表示年份）</span><br><span class="line">%z  与UTC时间的间隔（如果是本地时间，返回空字符串）</span><br><span class="line">%Z  时区的名字（如果是本地时间，返回空字符串）       </span><br><span class="line">%%  ‘%’字符  </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,  formattime)</span><br><span class="line"><span class="string">&#x27;2015-08-24 13:01:30&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="time-strptime-string-format"><a href="#time-strptime-string-format" class="headerlink" title="time.strptime(string[,format])"></a>time.strptime(string[,format])</h2><p>将格式字符串转化成struct_time.<br>该函数是time.strftime()函数的逆操作。time strptime() 函数根据指定的格式把一个时间字符串解析为时间元组。所以函数返回的是struct_time对象。<br>参数：<br>string ：时间字符串<br>format：格式化字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>stime = <span class="string">&quot;2015-08-24 13:01:30&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>formattime = time.strptime(stime,<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> formattime</span><br><span class="line">time.struct_time(tm_year=<span class="number">2015</span>, tm_mon=<span class="number">8</span>, tm_mday=<span class="number">24</span>, tm_hour=<span class="number">13</span>, tm_min=<span class="number">1</span>, tm_sec=<span class="number">30</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">236</span>, tm_isdst=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
        <tag>time</tag>
      </tags>
  </entry>
  <entry>
    <title>title</title>
    <url>/hexoblog/2017/08/12/title/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/20/59e958907d2d2.jpg" alt="mahua"></p>
<span id="more"></span>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>top命令详解</title>
    <url>/hexoblog/2017/09/11/top%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ top</span><br><span class="line">top - <span class="number">00</span>:<span class="number">15</span>:<span class="number">40</span> <span class="keyword">up</span> <span class="number">21</span>:<span class="number">56</span>,  <span class="number">1</span> user,  load average: <span class="number">31.09</span>, <span class="number">29.87</span>, <span class="number">29.92</span></span><br><span class="line">Tasks: <span class="number">871</span> total,   <span class="number">1</span> running, <span class="number">868</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">2</span> zombie</span><br><span class="line">%Cpu(s): <span class="number">96.8</span> us,  <span class="number">0.4</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,  <span class="number">2.7</span> id,  <span class="number">0.1</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">KiB Mem:  <span class="number">25190241</span>+total, <span class="number">24921688</span> used, <span class="number">22698073</span>+free,    <span class="number">60448</span> <span class="keyword">buffers</span></span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> used,        <span class="number">0</span> free.   <span class="number">554208</span> cached Mem</span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"><span class="number">20248</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">0.227</span>t <span class="number">0.012</span>t  <span class="number">18748</span> S  <span class="number">3090</span>  <span class="number">5.2</span>  <span class="number">29812</span>:<span class="number">58</span> java</span><br><span class="line"><span class="number">4213</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2722544</span>  <span class="number">64640</span>  <span class="number">44232</span> S  <span class="number">23.5</span>  <span class="number">0.0</span> <span class="number">233</span>:<span class="number">35.37</span> mesos-slave</span><br><span class="line"><span class="number">66128</span> titancl+  <span class="number">20</span>   <span class="number">0</span>   <span class="number">24344</span>   <span class="number">2332</span>   <span class="number">1172</span> R   <span class="number">1.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.07</span> top</span><br><span class="line"><span class="number">5235</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">38.227</span>g <span class="number">547004</span>  <span class="number">49996</span> S   <span class="number">0.7</span>  <span class="number">0.2</span>   <span class="number">2</span>:<span class="number">02.74</span> java</span><br><span class="line"><span class="number">4299</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">20.015</span>g <span class="number">2.682</span>g  <span class="number">16836</span> S   <span class="number">0.3</span>  <span class="number">1.1</span>  <span class="number">33</span>:<span class="number">14.42</span> java     </span><br><span class="line"><span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">33620</span>   <span class="number">2920</span>   <span class="number">1496</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">03.82</span> init</span><br><span class="line"><span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.02</span> kthreadd</span><br><span class="line"><span class="number">3</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">05.35</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">5</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:<span class="number">0</span>H</span><br><span class="line"><span class="number">6</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">06.94</span> kworker/u256:<span class="number">0</span></span><br><span class="line"><span class="number">8</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2</span>:<span class="number">38.05</span> rcu_sched</span><br></pre></td></tr></table></figure>

<p><code>第一行：</code>uptime命令一样</p>
<p>top：   这个没有什么意思，只是个名称而以<br>01：47：56 ：     系统当前时间<br>up 1:26   ：   系统开机到现在经过了多少时间<br>2 users  ：            当前2用户在线<br>load average:0.00,0.00,0.00：        系统1分钟、5分钟、15分钟的CPU负载信息</p>
<p><code>第二行：</code>vmstat</p>
<p>Tasks：英文意思是工作;任务;差事。<br>38 total：很好理解，就是当前有38个任务，也就是38个进程。<br>1 running：1个进程正在运行<br>37 sleeping：37个进程睡眠<br>0 stopped：停止的进程数<br>0 zombie：僵死的进程数<br>Cpu(s)：表示这一行显示CPU总体信息<br>0.0%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。<br>0.7%sy：内核占用CPU时间百分比<br>0.0%ni：renice值为负的任务的用户态进程的CPU时间百分比。nice是优先级的意思<br>99.3%id：空闲CPU时间百分比<br>0.0%wa：等待I&#x2F;O的CPU时间百分比<br>0.0%hi：CPU硬中断时间百分比<br>0.0%si：CPU软中断时间百分比<br>0.0%st：被偷走的时间</p>
<p><code>第三行：</code>free</p>
<p>Men：内存的意思<br>256412k total：物理内存总量<br>30156k used：使用的物理内存量<br>226256 free：空闲的物理内存量<br>8176k buffers：用作内核缓存的物理内存量<br>Swap：交换空间<br>337356k total：交换区总量<br>0k used：使用的交换区量<br>337356k free：空闲的交换区量<br>12160k cached：缓冲交换区总量</p>
<p><code>第四行：</code>pidstat</p>
<p>PID：进程的ID<br>USER：进程所有者<br>PR：进程的优先级别，越小越优先被执行<br>NInice：值<br>VIRT：进程占用的虚拟内存<br>RES：进程占用的物理内存<br>SHR：进程使用的共享内存<br>S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数<br>%CPU：进程占用CPU的使用率<br>%MEM：进程使用的物理内存和总内存的百分比<br>TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。<br>COMMAND：进程启动命令名称</p>
<p><code>一些常用的linux top命令操作指令：</code></p>
<p>q：退出top命令<br>空格：立即刷新<br>s：设置刷新时间间隔<br>c：显示命令完全模式<br>t:：显示或隐藏进程和CPU状态信息<br>m：显示或隐藏内存状态信息<br>l：显示或隐藏uptime信息<br>f：增加或减少进程显示标志<br>S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+<br>P：按%CPU使用率排行<br>T：按MITE+排行<br>M：按%MEM排行<br>u：指定显示用户进程<br>r：修改进程renice值<br>kkill：进程<br>i：只显示正在运行的进程<br>W：保存对top的设置到文件~&#x2F;.toprc，下次启动将自动调用toprc文件的设置。<br>h：帮助命令。<br><a href="http://www.itwhy.org/2011/07-05/437.html">原文</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu下安装dockers</title>
    <url>/hexoblog/2017/09/14/ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85dockers/</url>
    <content><![CDATA[<p><a href="http://www.linuxidc.com/Linux/2015-04/116051.htm">安装文档资料</a><br><a href="http://blog.csdn.net/quuqu/article/details/51488966">dockers安装troubleshooting资料</a><br><strong><code>内核变更</code></strong><br>docker再Linux的kernel3.8上运行最佳。<br>利用 uname -r命令查看当前系统版本的内核，内核版本不满足要求，升级内核：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install linux-image-generic-lts-raring linux-headers-generic-lts-raringsudo apt-<span class="built_in">get</span> install --install-recommends linux-generic-lts-raring xserver-xorg-lts-raring libgl1-mesa-glx-lts-raring</span><br><span class="line">~sudo reboot </span><br></pre></td></tr></table></figure>
<p>重启ubuntu</p>
<p><strong><code>更新apt-get的安装源</code></strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">root@linuxidc:~# <span class="keyword">vi</span> /etc/apt/sources.<span class="keyword">list</span></span><br></pre></td></tr></table></figure>
<p>是包管理工具 apt 所用的记录软件包仓库位置的配置文件<br><a href="http://blog.csdn.net/gong_xucheng/article/details/53886271">&#x2F;etc&#x2F;apt&#x2F;sources.list 详解</a><br>删除里面的所有内容，把下面的安装源写入</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-security main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-proposed main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span>-src http://mirrors.aliyun.<span class="keyword">com</span>/ubuntu/ trusty-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p><strong><code>然后更新apt-get，利用apt-get安装docker.io</code></strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">root@linuxidc:~#apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">root@linuxidc:~#apt-<span class="built_in">get</span> install docker.io</span><br><span class="line">root@linuxidc:~# service docker.io restart或者 service docker start</span><br></pre></td></tr></table></figure>

<p>错误信息<br>●报错1：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">FATA[<span class="number">0000</span>] Post http:///var/run/docker.sock/v1.<span class="number">18</span>/images/create?fromImage=wpscanteam%<span class="number">2</span>Fvulnerablewordpress%<span class="number">3</span>Alatest: dial unix /var/run/docker.sock: <span class="keyword">no</span> such <span class="keyword">file</span> <span class="built_in">or</span> directory. Are you trying <span class="keyword">to</span> connect <span class="keyword">to</span> <span class="keyword">a</span> TLS-enabled daemon without TLS?</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ sudo touch /var/run/docker.sock</span><br><span class="line">$ sudo docker -d</span><br></pre></td></tr></table></figure>

<p>touch命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。<br><a href="http://man.linuxde.net/touch">文档资料1</a><br>~docker -d :Run container in background and print container ID 运行容量并且打印容器ID<br><a href="http://www.cnblogs.com/go2bed/p/5703117.html">文档资料2</a></p>
<p>●报错2：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">INFO[<span class="number">0000</span>] +job serveapi(unix:///var/run/docker.sock) </span><br><span class="line">INFO[<span class="number">0000</span>] Listening <span class="keyword">for</span> HTTP <span class="keyword">on</span> unix (/var/run/docker.sock) </span><br><span class="line">INFO[<span class="number">0000</span>] +job init_networkdriver() </span><br><span class="line">INFO[<span class="number">0000</span>] -job init_networkdriver() = OK (<span class="number">0</span>) </span><br><span class="line">WARN[<span class="number">0000</span>] Your kernel does not support cgroup swap limit. </span><br><span class="line">FATA[<span class="number">0000</span>] Shutting down daemon due <span class="keyword">to</span> errors: Error loading docker apparmor <span class="keyword">profile</span>: fork/exec /sbin/apparmor_parser: <span class="keyword">no</span> such <span class="keyword">file</span></span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="built_in">get</span> install apparmor</span><br></pre></td></tr></table></figure>
<p>Apparmor—Linux内核中的强制访问控制系统，是Linux内核的一个安全模块，AppArmor允许系统管理员将每个程序与一个安全配置文件关联，从而限制程序的功能。简单的说，AppArmor是与SELinux类似的一个访问控制系统，通过它你可以指定程序可以读、写或运行哪些文件，是否可以打开网络端口等。作为对传统Unix的自主访问控制模块的补充，AppArmor提供了强制访问控制机制，它已经被整合到2.6版本的Linux内核中。<br><a href="http://www.cnblogs.com/-Lei/archive/2013/02/24/2923947.html">Apparmor</a></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>vector用法</title>
    <url>/hexoblog/2017/09/12/vector%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><a href="http://blog.csdn.net/hancunai0017/article/details/7032383">文档来自</a><br><strong><code>vector(向量):</code></strong></p>
<p>C++中的一种数据结构,确切的说是一个类.它相当于一个动态的数组,当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的.<br><code>文件包含:</code><br>首先在程序开头处加上#include<vector>以包含所需要的类文件vector还有一定要加上using namespace std;<br><code>变量声明:</code><br>声明一个int向量以替代一维的数组:vector <int> a;用vector代替二维数组.其实只要声明一个一维数组向量即可,而一个数组的名字其实代表的是它的首地址,所以只要声明一个地址的向量即可,即:vector &lt;int *&gt; a.同理想用向量代替三维数组也是一样,vector &lt;int**&gt;a;再往上面依此类推.int可以改成其他的如char、string甚至是strcut。<br><code>具体的用法以及函数调用:</code></p>
<ul>
<li><p>1.push_back   在数组的最后添加一个数据</p>
</li>
<li><p>2.pop_back    去掉数组的最后一个数据 </p>
</li>
<li><p>3.at                得到编号位置的数据</p>
</li>
<li><p>4.begin           得到数组头的指针</p>
</li>
<li><p>5.end             得到数组的最后一个单元+1的指针</p>
</li>
<li><p>6．front        得到数组头的引用</p>
</li>
<li><p>7.back            得到数组的最后一个单元的引用</p>
</li>
<li><p>8.max_size     得到vector最大可以是多大</p>
</li>
<li><p>9.capacity       当前vector分配的大小</p>
</li>
<li><p>10.size           当前使用数据的大小</p>
</li>
<li><p>11.resize         改变当前使用数据的大小，如果它比当前使用的大者填充默认值</p>
</li>
<li><p>12.reserve      改变当前vecotr所分配空间的大小</p>
</li>
<li><p>13.erase         删除指针指向的数据项</p>
</li>
<li><p>14.clear          清空当前的vector</p>
</li>
<li><p>15.rbegin        将vector反转后的开始指针返回(其实就是原来的end-1)</p>
</li>
<li><p>16.rend          将vector反转构的结束指针返回(其实就是原来的begin-1)</p>
</li>
<li><p>17.empty        判断vector是否为空</p>
</li>
<li><p>18.swap         与另一个vector交换数据<br><code>详细的函数实现功能:</code></p>
</li>
<li><p>c.clear()         移除容器中所有数据。</p>
</li>
<li><p>c.empty()         判断容器是否为空。</p>
</li>
<li><p>c.erase(pos)        删除pos位置的数据</p>
</li>
<li><p>c.erase(beg,end) 删除[beg,end]区间的数据 如： vec.erase(vec.begin()+2);删除第3个元素</p>
</li>
<li><p>c.front()         传回第一个数据。</p>
</li>
<li><p>c.insert(pos,elem)  在pos位置插入一个elem拷贝</p>
</li>
<li><p>c.pop_back()     删除最后一个数据。</p>
</li>
<li><p>c.push_back(elem) 在尾部加入一个数据。</p>
</li>
<li><p>c.resize(num)     重新设置该容器的大小</p>
</li>
<li><p>c.size()         回容器中实际数据的个数。</p>
</li>
<li><p>c.begin()           返回指向容器第一个元素的迭代器</p>
</li>
<li><p>c.end()             返回指向容器最后一个元素的迭代器                                  </p>
</li>
<li><p>c1.swap(c2)&#x3D;&#x3D;swap(c1,c2)         将c1和c2元素互换。两操作相同。</p>
</li>
</ul>
<p><code>#include&lt;algorithm&gt;中的泛函算法</code><br>搜索算法：find() 、search() 、count() 、find_if() 、search_if() 、count_if()<br>分类排序：sort() 、merge()<br>删除算法：unique() 、remove()<br>生成和变异：generate() 、fill() 、transformation() 、copy()<br>关系算法：equal() 、min() 、max() </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(v<span class="number">1.</span><span class="built_in">begin</span>(),vi.<span class="built_in">begin</span>()+v<span class="number">1.</span>size/<span class="number">2</span>）; </span><br></pre></td></tr></table></figure>
<p>对v1的前半段元素排序，默认是从小到大排序，即默认为冒泡排序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>对整个vector做排序<br>定义排序比较函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a,<span class="type">const</span> <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用时:sort(vec.begin(),vec.end(),cmp)，这样就降序排序。<br><code>其他功能:</code></p>
<ul>
<li>c.at(idx)  传回索引idx所指的数据，如果idx越界，抛出out_of_range。 </li>
<li>c.back()  传回最后一个数据，不检查这个数据是否存在。</li>
<li>c.front()  传回地一个数据。 </li>
<li>get_allocator  使用构造函数返回一个拷贝。 </li>
<li>c.rbegin()  传回一个逆向队列的第一个数据。 </li>
<li>c.rend()  传回一个逆向队列的最后一个数据的下一个位置。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数据结构</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>切片解析</title>
    <url>/hexoblog/2017/09/30/%E5%88%87%E7%89%87%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>切片操作符是序列名后跟一个方括号，方括号中有一对可选的数字，并用冒号分割。注意这与你使用的索引操作符十分相似。记住数是可选的，而冒号是必须的。<br>切片操作符中的第一个数（冒号之前）表示切片开始的位置，第二个数（冒号之后）表示切片到哪里结束，第三个数（冒号之后）表示切片间隔数。<br>如果不指定第一个数，Python就从序列首开始。如果没有指定第二个数，则Python会停止在序列尾。注意，返回的序列从开始位置开始 ，刚好在结束位置之前结束。即开始位置是包含在序列切片中的，而结束位置被排斥在切片外。这样，shoplist[1:3]返回从位置1开始，包括位置2，但是停止在位置3的一个序列切片，因此返回一个含有两个项目的切片。类似地，shoplist[:]返回整个序列的拷贝。shoplist[::3]返回位置3，位置6，位置9…的序列切片。你可以用负数做切片。负数用在从序列尾开始计算的位置。例如，shoplist[:-1]会返回除了最后一个项目外包含所有项目的序列切片，shoplist[::-1]会返回倒序序列切片。使用Python解释器交互地尝试不同切片指定组合，即在提示符下你能够马上看到结果。序列的神奇之处在于你可以用相同的方法访问元组、列表和字符串。</p>
<p><a href="http://blog.csdn.net/anneqiqi/article/details/61918181">参考资料地址</a><br><img src="https://i.loli.net/2017/10/20/59e9cfde07249.png" alt="tu"><br>多个冒号可以用一个省略号（…）来代替，主要运用与多维数组当中</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>四七层模型协议比较</title>
    <url>/hexoblog/2017/08/12/%E5%9B%9B%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%8D%8F%E8%AE%AE%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<p><strong><code>OSI (Open System Interconnection)</code></strong><br>开放式系统互联参考模型。从下到上七层模型功能及其代表协议：</p>
<ul>
<li>物理层(Physical) ：规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。Bit，比特。典型协议代表：EIA&#x2F;TIA-232, EIA&#x2F;TIA-499, V.35, V.24, RJ45, Ethernet, IEEE 802.3x(以太网) 物理层, FDDI(Fiber Distributed Data Interface, 光纤分布式数据接口) 物理层</li>
<li>数据链路层(Data Link) : 在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。Frame，帧。典型协议代表：SDLC(Synchronous DataLink Control，同步数据链路控制), HDLC(High-Level Data Link Control, 高级数据链路控制), PPP(Point-to-Point 点到点), IEEE 802.3x 数据链路层, FDDI 数据链路层, ATM(Asynchronous Transfer Mode, 异步传输模式), IEEE 802.5(令牌环) , Frame Relay(帧中继)</li>
<li>网络层(Network) : 负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。 Packet，包。典型协议代表：IP, ICMP, IGMP, IPX, BGP, OSPF, RIP, IGRP, EIGRP, ARP, RARP, X.25</li>
<li>传输层(Transport) : 传输层是第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 Segment，段。典型协议代表：TCP, UDP, TLS, RTP, SCTP, SPX, ATP, IL</li>
<li>会话层(Session) : 管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。典型协议代表：RPC, SQL, NFS, NetBIOS, SCP, ASP, SSH, Winsock, BSD sockets</li>
<li>表示层(Presentation) : 对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。典型协议代表：TIFF, GIF, JPEG, PICT, ASCII, EBCDIC, encryption, MPEG, MIDI, HTML</li>
<li>应用层(Application) : 为操作系统或网络应用程序提供访问网络服务的接口。典型协议代表：FTP, WWW, Telnet, NFS, SMTP, Gateway, SNMP, HTTP, Whois, SSH<br>OSI 七层模型各层设备：<br>物理层：各种传输媒体(光线，网线)，各类 DTE 和 DCE 之间通讯的物理设备(计算机， HUB)，各类插槽，插座<br>数据链路层：两个子层：LLC(Logical Link Control, 逻辑链路控制层)，MAC(Media Access Control，媒体访问控制层)。网卡，网桥和二层交换机<br>网路层：路由器，网关和三层交换机<br>传输层：四层交换机<br>会话层：五层交换机<br>表示层：六层交换机<br>应用层：计算机，负载均衡和七成交换机</li>
</ul>
<hr>
<p><strong><code>TCP/IP网络协议</code></strong><br>TCP&#x2F;IP(Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网间网协议)是目前世界上应用最为广泛的协议，它的流行与 Internet 的迅猛发展密切相关。TCP&#x2F;IP 最初是为互联网的原型 ARPANET 所设计的，目的是提供一整套方便实用、能应用于多种网络上的协议，事实证明 TCP&#x2F;IP 做到了这一点，它使网络互联变得容易起来，并且使越来越多的网络加入其中，成为 Internet 的事实标准。<br>TCP&#x2F;IP 参考模型分为四个层次：</p>
<ul>
<li>主机到网络层:实际上TCP&#x2F;IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。</li>
<li>网络互连层：定义了分组格式和协议，即IP协议（Internet Protocol）。网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。</li>
<li>传输层：使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。 　　 　　UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。</li>
<li>应用层：包括 OSI 参考模型中的会话层和表示层。面向不同的网络应用引入不同的应用层协议。其中，有基于 TCP 协议的，如 FTP(File Transfer Protocol，文件传输协议)， Telnet(虚拟终端协议)， HTTP(Hyper Text Transfer Protocol，超文本链接协议)；基于 UDP 协议的：如 SNMP, TFTP，NTP。</li>
</ul>
<hr>
<p><strong><code>OSI七层协议和TCP/IP四层协议之比较:</code></strong></p>
<ul>
<li>分层结构<br>OSI参考模型与TCP&#x2F;IP协议都采用了分层结构，都是基于独立的协议栈的概念。OSI参考模型有7层，而TCP&#x2F;IP协议只有 4 层，即 TCP&#x2F;IP协议没有了表示层和会话层，并且把数据链路层和物理层合并为网络接口层。不过，二者的分层之间有一定的对应关系</li>
<li>标准的特色<br>OSI 参考模型的标准最早是由 ISO 和 CCITT (ITU的前身)制定的，有浓厚的通信背景，因此也打上了深厚的通信系统的特色，比如对服务质量（QoS）、差错率的保证，只考虑了面向连接的服务。并且是先定义一套功能完整的构架，再根据该构架来发展相应的协议与系统。<br>TCP&#x2F;IP 协议产生于对 Internet 网络的研究与实践中，是应实际需求而产生的，再由 IAB、IETF 等组织标准化，而并不是之前定义一个严谨的框架。而且 TCP&#x2F;IP 最早是在 UNIX 系统中实现的，考虑了计算机网络的特点，比较适合计算机实现和使用。 </li>
<li>连接服务<br>OSI 的网络层基本与 TCP&#x2F;IP 的网际层对应，二者的功能基本相似，但是寻址方式有较大的区别。<br>OSI的地址空间为不固定的可变长，由选定的地址命名方式决定，最长可达 160byte，可以容纳非常大的网络，因而具有较大的成长空间。根据 OSI 的规定，网络上每个系统至多可以有 256 个通信地址。<br>TCP&#x2F;IP网络的地址空间为固定的 4byte (在目前常用的 IPv4 中是这样，在 IPv6 中将扩展到 16byte)。网络上的每一个系统至少有一个唯一的地址与之对应。 </li>
<li>传输服务<br>OSI 与 TCP&#x2F;IP 的传输层都对不同的业务采取不同的传输策略。OSI 定义了五个不同层次的服务：TP1，TP2，TP3，TP4，TP5。TCP&#x2F;I P定义了 TCP 和 UDP 两种协议，分别具有面向连接和面向无连接的性质。其中 TCP 与 OSI 中的 TP4，UDP 与OSI中的 TP0 在构架和功能上大体相同，只是内部细节有一些差异。</li>
<li>应用范围<br>OSI 由于体系比较复杂，而且设计先于实现，有许多设计过于理想，不太方便计算机软件实现，因而完全实现 OSI 参考模型的系统并不多，应用的范围有限。而 TCP&#x2F;IP 协议最早在计算机系统中实现，在 UNIX、Windows平台中都有稳定的实现，并且提供了简单方便的编程接口 (API)，可以在其上开发出丰富的应用程序，因此得到了广泛的应用。TCP&#x2F;IP 协议已成为目前网际互联事实上的国际标准和工业标准。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>网络协议</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>网络协议</tag>
        <tag>tcp/ip</tag>
      </tags>
  </entry>
  <entry>
    <title>linux服务器查看性能的几个命令</title>
    <url>/hexoblog/2017/09/12/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9F%A5%E7%9C%8B%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>一、uptime命令</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ uptime</span><br><span class="line"><span class="number">23</span>:<span class="number">51</span>:<span class="number">26</span> <span class="keyword">up</span> <span class="number">21</span>:<span class="number">31</span>,  <span class="number">1</span> user,  load average: <span class="number">30.02</span>, <span class="number">26.43</span>, <span class="number">19.02</span></span><br></pre></td></tr></table></figure>

<p>这个命令可以快速查看机器的负载情况。在Linux系统中，这些数据表示等待CPU资源的进程和阻塞在不可中断IO进程（进程状态为D）的数量。这些数据可以让我们对系统资源使用有一个宏观的了解。<br>命令的输出分别表示<strong>1分钟、5分钟、15分钟的平均负载情况</strong>。通过这三个数据，可以了解服务器负载是在趋于紧张还是趋于缓解。如果1分钟平均负载很高，而15分钟平均负载很低，说明服务器正在命令高负载情况，需要进一步排查CPU资源都消耗在了哪里。反之，如果15分钟平均负载很高，1分钟平均负载较低，则有可能是CPU资源紧张时刻已经过去。<br>上面例子中的输出，可以看见最近1分钟的平均负载非常高，且远高于最近15分钟负载，因此我们需要继续排查当前系统中有什么进程消耗了大量的资源。可以通过下文将会介绍的vmstat、mpstat等命令进一步排查。</p>
<hr>
<p><code>二、dmesg命令</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ dmesg | tail</span><br><span class="line">[<span class="number">1880957.563150</span>] <span class="keyword">perl</span> invoked oom-killer: gfp_mask=<span class="number">0</span>x280da, order=<span class="number">0</span>, oom_score_adj=<span class="number">0</span></span><br><span class="line">[...]</span><br><span class="line">[<span class="number">1880957.563400</span>] Out of memory: Kill process <span class="number">18694</span> (<span class="keyword">perl</span>) score <span class="number">246</span> <span class="built_in">or</span> sacrifice child</span><br><span class="line">[<span class="number">1880957.563408</span>] Killed process <span class="number">18694</span> (<span class="keyword">perl</span>) total-<span class="keyword">vm</span>:<span class="number">1972392</span>kB, anon-rs<span class="variable">s:1953348kB</span>, <span class="keyword">file</span>-rs<span class="variable">s:0kB</span></span><br><span class="line">[<span class="number">2320864.954447</span>] TCP: Possible SYN flooding <span class="keyword">on</span> port <span class="number">7001</span>. Dropping</span><br><span class="line">request.  Check SNMP counters.</span><br></pre></td></tr></table></figure>

<p>该命令会输出系统日志的最后10行。示例中的输出，可以看见一次内核的oom kill和一次TCP丢包。这些日志可以帮助排查性能问题。千万不要忘了这一步。</p>
<hr>
<p><code>三、vmstat命令</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ vmstat <span class="number">1</span></span><br><span class="line">procs ---------memory---------- ---swap-- -----io---- -<span class="built_in">system</span>-- ------cpu-----</span><br><span class="line">r  <span class="keyword">b</span> swpd   free   buff  cache   si   <span class="keyword">so</span>    bi    <span class="keyword">bo</span>   in   <span class="keyword">cs</span> us <span class="keyword">sy</span> id <span class="keyword">wa</span> <span class="keyword">st</span></span><br><span class="line"><span class="number">34</span>  <span class="number">0</span>    <span class="number">0</span> <span class="number">200889792</span>  <span class="number">73708</span> <span class="number">591828</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">5</span>    <span class="number">6</span>   <span class="number">10</span> <span class="number">96</span>  <span class="number">1</span>  <span class="number">3</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">32</span>  <span class="number">0</span>    <span class="number">0</span> <span class="number">200889920</span>  <span class="number">73708</span> <span class="number">591860</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">592</span> <span class="number">13284</span> <span class="number">4282</span> <span class="number">98</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">32</span>  <span class="number">0</span>    <span class="number">0</span> <span class="number">200890112</span>  <span class="number">73708</span> <span class="number">591860</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span> <span class="number">9501</span> <span class="number">2154</span> <span class="number">99</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">32</span>  <span class="number">0</span>    <span class="number">0</span> <span class="number">200889568</span>  <span class="number">73712</span> <span class="number">591856</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">48</span> <span class="number">11900</span> <span class="number">2459</span> <span class="number">99</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">32</span>  <span class="number">0</span>    <span class="number">0</span> <span class="number">200890208</span>  <span class="number">73712</span> <span class="number">591860</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span> <span class="number">15898</span> <span class="number">4840</span> <span class="number">98</span>  <span class="number">1</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>vmstat(8) 命令，<strong>每行会输出一些系统核心指标，这些指标可以让我们更详细的了解系统状态</strong>。后面跟的参数1，表示每秒输出一次统计信息，表头提示了每一列的含义，这几介绍一些和性能调优相关的列：</p>
<ul>
<li>r：等待在CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况，数据中不包含等待IO的进程。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。</li>
<li>free：系统可用内存数（以千字节为单位），如果剩余内存不足，也会导致系统性能问题。下文介绍到的free命令，可以更详细的了解系统内存的使用情况。</li>
<li>si，so：交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。</li>
<li>us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。上述这些CPU时间，可以让我们很快了解CPU是否出于繁忙状态。一般情况下，如果用户时间和系统时间相加非常大，CPU出于忙于执行指令。如果IO等待时间很长，那么系统的瓶颈可能在磁盘IO。</li>
</ul>
<p>示例命令的输出可以看见，大量CPU时间消耗在用户态，也就是用户应用程序消耗了CPU时间。这不一定是性能问题，需要结合r队列，一起分析。</p>
<hr>
<p><code>四、mpstat命令</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ mpstat -<span class="keyword">P</span> ALL <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">49</span>-generic (titanclusters-xxxxx)  <span class="number">07</span>/<span class="number">14</span>/<span class="number">2015</span>  _x86_64_ (<span class="number">32</span> CPU)</span><br><span class="line"><span class="number">07</span>:<span class="number">38</span>:<span class="number">49</span> PM  CPU   %usr  %nice   %sys %iowait   %irq  %soft  %steal  %guest  %gnice  %idle</span><br><span class="line"><span class="number">07</span>:<span class="number">38</span>:<span class="number">50</span> PM  <span class="keyword">all</span>  <span class="number">98.47</span>   <span class="number">0.00</span>   <span class="number">0.75</span>    <span class="number">0.00</span>   <span class="number">0.00</span>   <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">0.78</span></span><br><span class="line"><span class="number">07</span>:<span class="number">38</span>:<span class="number">50</span> PM    <span class="number">0</span>  <span class="number">96.04</span>   <span class="number">0.00</span>   <span class="number">2.97</span>    <span class="number">0.00</span>   <span class="number">0.00</span>   <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">0.99</span></span><br><span class="line"><span class="number">07</span>:<span class="number">38</span>:<span class="number">50</span> PM    <span class="number">1</span>  <span class="number">97.00</span>   <span class="number">0.00</span>   <span class="number">1.00</span>    <span class="number">0.00</span>   <span class="number">0.00</span>   <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">2.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">38</span>:<span class="number">50</span> PM    <span class="number">2</span>  <span class="number">98.00</span>   <span class="number">0.00</span>   <span class="number">1.00</span>    <span class="number">0.00</span>   <span class="number">0.00</span>   <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">1.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">38</span>:<span class="number">50</span> PM    <span class="number">3</span>  <span class="number">96.97</span>   <span class="number">0.00</span>   <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">0.00</span>   <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>   <span class="number">3.03</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>该命令可以显示每个CPU的占用情况，如果有一个CPU占用率特别高，那么有可能是一个单线程应用程序引起的。</p>
<hr>
<p><code>五、pidstat命令</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ pidstat <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">49</span>-generic (titanclusters-xxxxx)  <span class="number">07</span>/<span class="number">14</span>/<span class="number">2015</span>    _x86_64_    (<span class="number">32</span> CPU)</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">02</span> PM   UID       PID    %usr %<span class="built_in">system</span>  %guest    %CPU   CPU  Command</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">03</span> PM     <span class="number">0</span>         <span class="number">9</span>    <span class="number">0.00</span>    <span class="number">0.94</span>    <span class="number">0.00</span>    <span class="number">0.94</span>     <span class="number">1</span>  rcuos/<span class="number">0</span></span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">03</span> PM     <span class="number">0</span>      <span class="number">4214</span>    <span class="number">5.66</span>    <span class="number">5.66</span>    <span class="number">0.00</span>   <span class="number">11.32</span>    <span class="number">15</span>  mesos-slave</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">03</span> PM     <span class="number">0</span>      <span class="number">4354</span>    <span class="number">0.94</span>    <span class="number">0.94</span>    <span class="number">0.00</span>    <span class="number">1.89</span>     <span class="number">8</span>  java</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">03</span> PM     <span class="number">0</span>      <span class="number">6521</span> <span class="number">1596.23</span>    <span class="number">1.89</span>    <span class="number">0.00</span> <span class="number">1598.11</span>    <span class="number">27</span>  java</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">03</span> PM     <span class="number">0</span>      <span class="number">6564</span> <span class="number">1571.70</span>    <span class="number">7.55</span>    <span class="number">0.00</span> <span class="number">1579.25</span>    <span class="number">28</span>  java</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">03</span> PM <span class="number">60004</span>     <span class="number">60154</span>    <span class="number">0.94</span>    <span class="number">4.72</span>    <span class="number">0.00</span>    <span class="number">5.66</span>     <span class="number">9</span>  pidstat</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">03</span> PM   UID       PID    %usr %<span class="built_in">system</span>  %guest    %CPU   CPU  Command</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">04</span> PM     <span class="number">0</span>      <span class="number">4214</span>    <span class="number">6.00</span>    <span class="number">2.00</span>    <span class="number">0.00</span>    <span class="number">8.00</span>    <span class="number">15</span>  mesos-slave</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">04</span> PM     <span class="number">0</span>      <span class="number">6521</span> <span class="number">1590.00</span>    <span class="number">1.00</span>    <span class="number">0.00</span> <span class="number">1591.00</span>    <span class="number">27</span>  java07:<span class="number">41</span>:<span class="number">04</span> PM     <span class="number">0</span>      <span class="number">6564</span> <span class="number">1573.00</span>   <span class="number">10.00</span>    <span class="number">0.00</span> <span class="number">1583.00</span>    <span class="number">28</span>  java</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">04</span> PM   <span class="number">108</span>      <span class="number">6718</span>    <span class="number">1.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">1.00</span>     <span class="number">0</span>  snmp-pass</span><br><span class="line"><span class="number">07</span>:<span class="number">41</span>:<span class="number">04</span> PM <span class="number">60004</span>     <span class="number">60154</span>    <span class="number">1.00</span>    <span class="number">4.00</span>    <span class="number">0.00</span>    <span class="number">5.00</span>     <span class="number">9</span>  pidstat</span><br></pre></td></tr></table></figure>

<p>pidstat命令输出<strong>进程的CPU占用率</strong>，该命令会持续输出，并且不会覆盖之前的数据，可以方便观察系统动态。如上的输出，可以看见两个JAVA进程占用了将近1600%的CPU时间，既消耗了大约16个CPU核心的运算资源。</p>
<hr>
<p><code>六、iostat命令</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ iostat -xz <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">49</span>-generic (titanclusters-xxxxx)  <span class="number">07</span>/<span class="number">14</span>/<span class="number">2015</span>  _x86_64_ (<span class="number">32</span> CPU)</span><br><span class="line">avg-cpu:  %user   %nice %<span class="built_in">system</span> %iowait  %steal   %idle</span><br><span class="line"><span class="number">73.96</span>    <span class="number">0.00</span>    <span class="number">3.73</span>    <span class="number">0.03</span>    <span class="number">0.06</span>   <span class="number">22.21</span></span><br><span class="line">Device:   rrqm/s   wrqm/s     r/s     <span class="keyword">w</span>/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">xvda        <span class="number">0.00</span>     <span class="number">0.23</span>    <span class="number">0.21</span>    <span class="number">0.18</span>     <span class="number">4.52</span>     <span class="number">2.08</span>    <span class="number">34.37</span>     <span class="number">0.00</span>    <span class="number">9.98</span>   <span class="number">13.80</span>    <span class="number">5.42</span>   <span class="number">2.44</span>   <span class="number">0.09</span></span><br><span class="line">xvdb        <span class="number">0.01</span>     <span class="number">0.00</span>    <span class="number">1.02</span>    <span class="number">8.94</span>   <span class="number">127.97</span>   <span class="number">598.53</span>   <span class="number">145.79</span>     <span class="number">0.00</span>    <span class="number">0.43</span>    <span class="number">1.78</span>    <span class="number">0.28</span>   <span class="number">0.25</span>   <span class="number">0.25</span></span><br><span class="line">xvdc        <span class="number">0.01</span>     <span class="number">0.00</span>    <span class="number">1.02</span>    <span class="number">8.86</span>   <span class="number">127.79</span>   <span class="number">595.94</span>   <span class="number">146.50</span>     <span class="number">0.00</span>    <span class="number">0.45</span>    <span class="number">1.82</span>    <span class="number">0.30</span>   <span class="number">0.27</span>   <span class="number">0.26</span></span><br><span class="line">dm-<span class="number">0</span>        <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.69</span>    <span class="number">2.32</span>    <span class="number">10.47</span>    <span class="number">31.69</span>    <span class="number">28.01</span>     <span class="number">0.01</span>    <span class="number">3.23</span>    <span class="number">0.71</span>    <span class="number">3.98</span>   <span class="number">0.13</span>   <span class="number">0.04</span></span><br><span class="line">dm-<span class="number">1</span>        <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.94</span>     <span class="number">0.01</span>     <span class="number">3.78</span>     <span class="number">8.00</span>     <span class="number">0.33</span>  <span class="number">345.84</span>    <span class="number">0.04</span>  <span class="number">346.81</span>   <span class="number">0.01</span>   <span class="number">0.00</span></span><br><span class="line">dm-<span class="number">2</span>        <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.09</span>    <span class="number">0.07</span>     <span class="number">1.35</span>     <span class="number">0.36</span>    <span class="number">22.50</span>     <span class="number">0.00</span>    <span class="number">2.55</span>    <span class="number">0.23</span>    <span class="number">5.62</span>   <span class="number">1.78</span>   <span class="number">0.03</span></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<p>iostat命令主要用于查看<strong>机器磁盘IO</strong>情况。该命令输出的列，主要含义是：</p>
<ul>
<li>r&#x2F;s, w&#x2F;s, rkB&#x2F;s, wkB&#x2F;s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。</li>
<li>await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。</li>
<li>avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。</li>
<li>%util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。</li>
</ul>
<p>如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。</p>
<hr>
<p><code>七、free命令</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ free -<span class="keyword">m</span></span><br><span class="line">total       used       free     shared    <span class="keyword">buffers</span>     cached</span><br><span class="line">Mem:        <span class="number">245998</span>      <span class="number">24545</span>     <span class="number">221453</span>         <span class="number">83</span>         <span class="number">59</span>        <span class="number">541</span></span><br><span class="line">-/+ <span class="keyword">buffers</span>/cache:      <span class="number">23944</span>     <span class="number">222053</span></span><br><span class="line">Swap:            <span class="number">0</span>          <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>free命令可以查看<strong>系统内存的使用情况</strong>，-m参数表示按照兆字节展示。最后两列分别表示用于IO缓存的内存数，和用于文件系统页缓存的内存数。需要注意的是，第二行-&#x2F;+ buffers&#x2F;cache，看上去缓存占用了大量内存空间。<br>这是Linux系统的内存使用策略，尽可能的利用内存，如果应用程序需要内存，这部分内存会立即被回收并分配给应用程序。因此，这部分内存一般也被当成是可用内存。<br>如果可用内存非常少，系统可能会动用交换区（如果配置了的话），这样会增加IO开销（可以在iostat命令中提现），降低系统性能。</p>
<hr>
<p><code>八、sar命令</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ sar -n DEV <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">49</span>-generic (titanclusters-xxxxx)  <span class="number">07</span>/<span class="number">14</span>/<span class="number">2015</span>     _x86_64_    (<span class="number">32</span> CPU)</span><br><span class="line"><span class="number">12</span>:<span class="number">16</span>:<span class="number">48</span> AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line"><span class="number">12</span>:<span class="number">16</span>:<span class="number">49</span> AM      eth0  <span class="number">18763.00</span>   <span class="number">5032.00</span>  <span class="number">20686.42</span>    <span class="number">478.30</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">12</span>:<span class="number">16</span>:<span class="number">49</span> AM        <span class="keyword">lo</span>     <span class="number">14.00</span>     <span class="number">14.00</span>      <span class="number">1.36</span>      <span class="number">1.36</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">12</span>:<span class="number">16</span>:<span class="number">49</span> AM   docker0      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">12</span>:<span class="number">16</span>:<span class="number">49</span> AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil</span><br><span class="line"><span class="number">12</span>:<span class="number">16</span>:<span class="number">50</span> AM      eth0  <span class="number">19763.00</span>   <span class="number">5101.00</span>  <span class="number">21999.10</span>    <span class="number">482.56</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">12</span>:<span class="number">16</span>:<span class="number">50</span> AM        <span class="keyword">lo</span>     <span class="number">20.00</span>     <span class="number">20.00</span>      <span class="number">3.25</span>      <span class="number">3.25</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">12</span>:<span class="number">16</span>:<span class="number">50</span> AM   docker0      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure>

<p>sar命令在这里可以查看<strong>网络设备的吞吐率</strong>。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和。如示例输出中，eth0网卡设备，吞吐率大概在22 Mbytes&#x2F;s，既176 Mbits&#x2F;sec，没有达到1Gbit&#x2F;sec的硬件上限。<br>sar -n TCP,ETCP 1</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ sar -n TCP,ETCP <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.13</span>.<span class="number">0</span>-<span class="number">49</span>-generic (titanclusters-xxxxx)  <span class="number">07</span>/<span class="number">14</span>/<span class="number">2015</span>    _x86_64_    (<span class="number">32</span> CPU)</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">19</span> AM  active/s passive/s    iseg/s    oseg/s</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">20</span> AM      <span class="number">1.00</span>      <span class="number">0.00</span>  <span class="number">10233.00</span>  <span class="number">18846.00</span></span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">19</span> AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">20</span> AM      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">20</span> AM  active/s passive/s    iseg/s    oseg/s</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">21</span> AM      <span class="number">1.00</span>      <span class="number">0.00</span>   <span class="number">8359.00</span>   <span class="number">6039.00</span></span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">20</span> AM  atmptf/s  estres/s retrans/s isegerr/s   orsts/s</span><br><span class="line"><span class="number">12</span>:<span class="number">17</span>:<span class="number">21</span> AM      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure>

<p>sar命令在这里用于<strong>查看TCP连接状态</strong>，其中包括：</p>
<ul>
<li>active&#x2F;s：每秒本地发起的TCP连接数，既通过connect调用创建的TCP连接；</li>
<li>passive&#x2F;s：每秒远程发起的TCP连接数，即通过accept调用创建的TCP连接；</li>
<li>retrans&#x2F;s：每秒TCP重传数量；</li>
</ul>
<p>TCP连接数可以用来判断性能问题是否由于建立了过多的连接，进一步可以判断是主动发起的连接，还是被动接受的连接。TCP重传可能是因为网络环境恶劣，或者服务器压</p>
<p>sar命令也可以查看指定pid的信息</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ sar -<span class="keyword">x</span> pid <span class="number">1</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<hr>
<p><code>九、top命令</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ top</span><br><span class="line">top - <span class="number">00</span>:<span class="number">15</span>:<span class="number">40</span> <span class="keyword">up</span> <span class="number">21</span>:<span class="number">56</span>,  <span class="number">1</span> user,  load average: <span class="number">31.09</span>, <span class="number">29.87</span>, <span class="number">29.92</span></span><br><span class="line">Tasks: <span class="number">871</span> total,   <span class="number">1</span> running, <span class="number">868</span> sleeping,   <span class="number">0</span> stopped,   <span class="number">2</span> zombie</span><br><span class="line">%Cpu(s): <span class="number">96.8</span> us,  <span class="number">0.4</span> <span class="keyword">sy</span>,  <span class="number">0.0</span> ni,  <span class="number">2.7</span> id,  <span class="number">0.1</span> <span class="keyword">wa</span>,  <span class="number">0.0</span> <span class="keyword">hi</span>,  <span class="number">0.0</span> si,  <span class="number">0.0</span> <span class="keyword">st</span></span><br><span class="line">KiB Mem:  <span class="number">25190241</span>+total, <span class="number">24921688</span> used, <span class="number">22698073</span>+free,    <span class="number">60448</span> <span class="keyword">buffers</span></span><br><span class="line">KiB Swap:        <span class="number">0</span> total,        <span class="number">0</span> used,        <span class="number">0</span> free.   <span class="number">554208</span> cached Mem</span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"><span class="number">20248</span> root      <span class="number">20</span>   <span class="number">0</span>  <span class="number">0.227</span>t <span class="number">0.012</span>t  <span class="number">18748</span> S  <span class="number">3090</span>  <span class="number">5.2</span>  <span class="number">29812</span>:<span class="number">58</span> java</span><br><span class="line"><span class="number">4213</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">2722544</span>  <span class="number">64640</span>  <span class="number">44232</span> S  <span class="number">23.5</span>  <span class="number">0.0</span> <span class="number">233</span>:<span class="number">35.37</span> mesos-slave</span><br><span class="line"><span class="number">66128</span> titancl+  <span class="number">20</span>   <span class="number">0</span>   <span class="number">24344</span>   <span class="number">2332</span>   <span class="number">1172</span> R   <span class="number">1.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.07</span> top</span><br><span class="line"><span class="number">5235</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">38.227</span>g <span class="number">547004</span>  <span class="number">49996</span> S   <span class="number">0.7</span>  <span class="number">0.2</span>   <span class="number">2</span>:<span class="number">02.74</span> java</span><br><span class="line"><span class="number">4299</span> root      <span class="number">20</span>   <span class="number">0</span> <span class="number">20.015</span>g <span class="number">2.682</span>g  <span class="number">16836</span> S   <span class="number">0.3</span>  <span class="number">1.1</span>  <span class="number">33</span>:<span class="number">14.42</span> java     </span><br><span class="line"><span class="number">1</span> root      <span class="number">20</span>   <span class="number">0</span>   <span class="number">33620</span>   <span class="number">2920</span>   <span class="number">1496</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">03.82</span> init</span><br><span class="line"><span class="number">2</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.02</span> kthreadd</span><br><span class="line"><span class="number">3</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">05.35</span> ksoftirqd/<span class="number">0</span></span><br><span class="line"><span class="number">5</span> root       <span class="number">0</span> -<span class="number">20</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">00.00</span> kworker/<span class="number">0</span>:<span class="number">0</span>H</span><br><span class="line"><span class="number">6</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">0</span>:<span class="number">06.94</span> kworker/u256:<span class="number">0</span></span><br><span class="line"><span class="number">8</span> root      <span class="number">20</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span> S   <span class="number">0.0</span>  <span class="number">0.0</span>   <span class="number">2</span>:<span class="number">38.05</span> rcu_sched</span><br></pre></td></tr></table></figure>

<p>top命令<strong>包含了前面好几个命令的检查的内容。比如系统负载情况（uptime）、系统内存使用情况（free）、系统CPU使用情况（vmstat）等。因此通过这个命令，可以相对全面的查看系统负载的来源</strong>。同时，top命令支持排序，可以按照不同的列排序，方便查找出诸如内存占用最多的进程、CPU占用率最高的进程等。<br>但是，top命令相对于前面一些命令，输出是一个瞬间值，如果不持续盯着，可能会错过一些线索。这时可能需要暂停top命令刷新，来记录和比对数据。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>图BFS最小转机问题</title>
    <url>/hexoblog/2017/08/12/%E5%9B%BEBFS%E6%9C%80%E5%B0%8F%E8%BD%AC%E6%9C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>思路：<br>我们假设所有边的长度都是1，每一个线段表示一个转机，求最少转机就是求最短路径而已<br>深度优先和广度优先的方法都可以，但是广度优先更适合所有边的权重一样的情况<br>输入：<br>第一行n,m,p,q分别为站点个数，航线个数，起始点，目的地<br>后面m行表示m条航线<br>输出：<br>最小转机数量<br>样例：<br>5 7 1 5<br>1 2<br>1 3<br>2 3<br>2 4<br>3 4<br>3 5<br>4 5</p>
<p>2</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">n,line</span>): <span class="comment">#存储图的关系与标记数组</span></span><br><span class="line">    e=[[<span class="number">99999</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)] <span class="comment">#初始化所有的线路都为最大值99999</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        e[i][i]=<span class="number">0</span> <span class="comment">#自己和自己之间没有线路</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(line)): <span class="comment">#根据m行输入，确定哪一些节点之间是有航线的，</span></span><br><span class="line">        a,b=line[i]</span><br><span class="line">        a=<span class="built_in">int</span>(a)</span><br><span class="line">        b=<span class="built_in">int</span>(b)</span><br><span class="line">        e[a][b]=<span class="number">1</span> <span class="comment">#节点之间有航班即为往返都可通行，即为双向图</span></span><br><span class="line">        e[b][a]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> e</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">n,m,p,q,e</span>):</span><br><span class="line">    head=<span class="number">1</span></span><br><span class="line">    tail=<span class="number">1</span></span><br><span class="line">    que=[[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    que[tail]=[p,<span class="number">0</span>]</span><br><span class="line">    tail +=<span class="number">1</span></span><br><span class="line">    book=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    book.insert(p,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> head&lt;=tail:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;que=&#x27;</span>,que)</span><br><span class="line">        cur=que[head][<span class="number">0</span>] <span class="comment">#que队列中首航班号</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> e[cur][i]==<span class="number">1</span> <span class="keyword">and</span> book[i]==<span class="number">0</span>: <span class="comment">#利用方向图，从城市cur到城市i是否有航班并且判断城市i是否在队列中</span></span><br><span class="line">                que[tail]=[i,que[head][<span class="number">1</span>]+<span class="number">1</span>] <span class="comment">#满足条件，cur到城市i有航班并且城市i不在队列中，则i入队，转机次数+1</span></span><br><span class="line">                tail +=<span class="number">1</span></span><br><span class="line">                book[i]=<span class="number">1</span> <span class="comment">#改变标记，以防重用 </span></span><br><span class="line">            <span class="keyword">if</span> tail==q+<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span>(que[tail-<span class="number">1</span>][<span class="number">1</span>]) <span class="comment">#由于tail是指向队列队尾的下一个位置，所以减1 </span></span><br><span class="line">        head +=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n,m,p,q=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> raw_input().split()]</span><br><span class="line">    line=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(m)):</span><br><span class="line">        line.append(raw_input().split())</span><br><span class="line">    e=[]</span><br><span class="line">    <span class="built_in">print</span> (line)</span><br><span class="line">    e=change(n,line)</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    ans=bfs(n,m,p,q,e)</span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
        <category>bfs</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>图dfs水池个数问题</title>
    <url>/hexoblog/2017/08/13/%E5%9B%BEdfs%E6%B0%B4%E6%B1%A0%E4%B8%AA%E6%95%B0%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>输入：<br>第一行输入一个整数N，表示共有N组测试数据<br>每一组数据都是先输入该地图的行数m(0&lt;m&lt;100)与列数n(0&lt;n&lt;100)，然后，输入接下来的m行每行输入n个数，表示此处有水还是没水（1表示此处是水池，0表示此处是地面）<br>输出：<br>输出该地图中水池的个数。<br>要注意，每个水池的旁边（上下左右四个位置）如果还是水池的话的话，它们可以看做是同一个水池。</p>
<hr>
<p>python代码，一直跑不出递归，已经醉了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys   </span><br><span class="line">sys.setrecursionlimit(<span class="number">1000000000</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i,j</span>):</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span> <span class="keyword">or</span> i&gt;=m <span class="keyword">or</span> j&lt;<span class="number">0</span> <span class="keyword">or</span> j&gt;=n <span class="keyword">or</span> (s[i][j]==<span class="number">0</span>)):</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    s[i][j]==<span class="number">0</span></span><br><span class="line">    dfs(i,j+<span class="number">1</span>)</span><br><span class="line">    dfs(i,j-<span class="number">1</span>)</span><br><span class="line">    dfs(i-<span class="number">1</span>,j)</span><br><span class="line">    dfs(i+<span class="number">1</span>,j)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#N=raw_input().split()</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s=[]</span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        m,n=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> raw_input().split()]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            s.append([<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> raw_input().split()])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> s[i][j]==<span class="number">1</span>:</span><br><span class="line">                    dfs(i,j)</span><br><span class="line">                    ans +=<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(ans)</span><br><span class="line">        <span class="built_in">print</span> s</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//C++代码： </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> s[<span class="number">101</span>][<span class="number">101</span>],n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;m||j&lt;<span class="number">0</span>||j&gt;n||s[i][j]==<span class="number">0</span>)<span class="comment">//当所有的点为0时说明这是一个水池</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      s[i][j]=<span class="number">0</span>;<span class="comment">//每次搜索一个点后，置为0，避免重复</span></span><br><span class="line">      <span class="comment">//从此点开始往四周扩展</span></span><br><span class="line">      <span class="built_in">dfs</span>(i,j<span class="number">+1</span>);</span><br><span class="line">      <span class="built_in">dfs</span>(i,j<span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">dfs</span>(i<span class="number">-1</span>,j);</span><br><span class="line">      <span class="built_in">dfs</span>(i<span class="number">+1</span>,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;N);</span><br><span class="line">    <span class="keyword">while</span>(N--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i,j,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));<span class="comment">//初始化，0表示地面，1表示水池</span></span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">       &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i][j]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">       &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i][j]==<span class="number">1</span>)<span class="comment">//每次从是水池的地方开始深搜</span></span><br><span class="line">                 &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(i,j);</span><br><span class="line">                    ans++; <span class="comment">//搜索结束后既为满足条件</span></span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);<span class="comment">//输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo和Github的博客搭建</title>
    <url>/hexoblog/2017/10/19/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGithub%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/20/59e98c20af367.png" alt="封面"></p>
<span id="more"></span>
<h2 id="搭建原理"><a href="#搭建原理" class="headerlink" title="搭建原理"></a>搭建原理</h2><p><code>github pages</code><br>github是项目托管网站，列出了项目的源文件，github有一个pages功能，可以自定义主页，用来代替默认的列出源列表的这个页面。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。对于个人博客的主页页面内容可以位于 master 下。user pages只有一个, project pages可以有多个, 对于个人博客而言, 两种方式都可以.如果用户申请了自己的域名, 还可以使用CNAME文件自定义domain name,这样访问你的域名就自动访问到github上的页面. 用户也可以自定义404页面.<br><code>Hexo</code><br>Hexo是一个快速、简洁并且高效的博客框架。Hexo使用Markdown解析文章，还可以使用期主题生成静态网页</p>
<hr>
<h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><p>大概可以分为以下几个步骤：</p>
<ul>
<li>搭建环境准备（包括node.js和git环境，gitHub账户的配置）</li>
<li>安装Hexo</li>
<li>配置Hexo</li>
<li>怎样将Hexo与github page联系起来</li>
<li>怎样发布文章</li>
<li>主题 推荐</li>
<li>主题Next的配置</li>
<li>添加404 公益页面</li>
</ul>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>配置Node.js安装环境：JavaScript工具，前端架构，编写出可扩展性高的服务器</p>
<ul>
<li>安装Online documentation shortcuts模块</li>
<li>新打开的窗口中输入cmd，敲击回车，打开命令行界面</li>
<li>查看安装的是否成功</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">node -v npm -v</span><br></pre></td></tr></table></figure>
<p>配置Git环境:Git工具可以在windows系统中的任意文件下进入命令行界面，可以建立Hexo和Github的连接</p>
<ul>
<li>安装Online documentation shortcuts模块</li>
<li>查看安装是否成功</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git --<span class="keyword">version</span></span><br></pre></td></tr></table></figure>
<p>github账号的配置</p>
<ul>
<li><p>新建一个repository，命名为hexoblog</p>
</li>
<li><p>在settings页面中的Github Pages中开启gh pages功能，记录网址可以用于后续配置<br>安装Hexo</p>
</li>
<li><p>新建一个目录并且创建Hexo文件夹，用于安装Hexo，并在命令行的窗口进入到该目录</p>
</li>
<li><p>命令行输入:安装hexo以及查看是否安装</p>
</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo --save</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>Hexo的体验</p>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<ul>
<li>安装npm组件</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<ul>
<li>生成</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<ul>
<li>开启端口</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>提示，在浏览器中输入以后网址既可以访问hexo界面</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">INFO Hexo <span class="keyword">is</span> running at http://<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">4000</span>/. Press Ctrl+C <span class="keyword">to</span> <span class="keyword">stop</span>.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="将hexo和github相连"><a href="#将hexo和github相连" class="headerlink" title="将hexo和github相连"></a>将hexo和github相连</h2><p>配置Git个人信息</p>
<ul>
<li>设置Git的user.name和user.email</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">&quot;Lander&quot;</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">&quot;dclarken@163.com&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成秘钥，生成的秘钥要使用需要配置为github上的安全ssh秘钥<br><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573399">Git ssh 配置使用</a></li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;dclarken@163.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>配置Deployment</p>
<ul>
<li>在hexo安装目录下找到根配置文件_config.yml文件，找到Deployment句段</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: repo: git@github.<span class="keyword">com</span>:dclarken/hexoblog.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>git插件安装</p>
<ul>
<li>提前安装一个扩展</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="主题配置以及文章发布"><a href="#主题配置以及文章发布" class="headerlink" title="主题配置以及文章发布"></a>主题配置以及文章发布</h2><p>Next主题配置使用</p>
<ul>
<li>安装Next，利用Git工具将下载的主题文件拷贝在themes目录下</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> your-hexo-site</span><br><span class="line">git clone https://github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<ul>
<li>启用主题，切换主题一般可以用hexo clean来清空缓存</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure>
<ul>
<li>验证主题，生成端口，访问网址观察是否成功配置</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hexo s –<span class="keyword">debug</span></span><br></pre></td></tr></table></figure>
<ul>
<li>主题设定<br><a href="http://theme-next.iissnan.com/">Next主题设定资料地址</a></li>
<li>添加文章，添加新的文章在source文件夹下的post文件中，文件名为引号中的字符</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> post <span class="string">&quot;article title&quot;</span></span><br></pre></td></tr></table></figure>
<p>文件格式为markdown格式，初始生成的文件内容如下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: article title</span><br><span class="line">date: <span class="number">2017</span>-<span class="number">8</span>-<span class="number">12</span> <span class="number">11</span>:<span class="number">31</span>:<span class="number">21</span></span><br><span class="line"><span class="keyword">tags</span>: [随笔,freinds]</span><br><span class="line">categories: [随笔]</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<ul>
<li>添加标签页面，如果不添加该页面在主题config配置文件中，添加的tags会指向404界面</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> your-hexo-site</span><br><span class="line">hexo <span class="keyword">new</span> page <span class="keyword">tags</span></span><br></pre></td></tr></table></figure>
<p>文件补充为以下格式：添加type字段，comments字段可以关闭评论</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: <span class="number">2017</span>-<span class="number">8</span>-<span class="number">12</span> <span class="number">12</span>:<span class="number">39</span>:<span class="number">04</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>
<ul>
<li>添加分类页面</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> your-hexo-site</span><br><span class="line">hexo <span class="keyword">new</span> page categories</span><br></pre></td></tr></table></figure>
<p>文件补充以下格式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: <span class="number">2017</span>-<span class="number">8</span>-<span class="number">12</span> <span class="number">12</span>:<span class="number">39</span>:<span class="number">04</span></span><br><span class="line"><span class="built_in">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure>

<hr>
<p>搭建过程参考资料：<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018">参考文章地址</a><br>致谢作者</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>npm</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>图dfs输出全排序</title>
    <url>/hexoblog/2017/08/13/%E5%9B%BEdfs%E8%BE%93%E5%87%BA%E5%85%A8%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>问题: 生成1~n的排列<br>思路: 穷举所有可能 在生成结果数组前把重复的去掉<br>探索到某一步发现原先选择达不到目标, 就退回一步重新选择.<br>效率比普通DFS高. 可以优化排列数和素数环的程序<br>两种代码一种没有加入回溯，一种有——-分隔</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding：utf-8</span></span><br><span class="line">A = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">N = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur</span>):</span><br><span class="line">    <span class="keyword">if</span> cur == N:</span><br><span class="line">        <span class="built_in">print</span>(A[:N])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> A[:cur]:</span><br><span class="line">                A[cur] = i</span><br><span class="line">                dfs(cur+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)]</span><br><span class="line">V = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)]</span><br><span class="line">N = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur</span>):</span><br><span class="line">    <span class="keyword">if</span> cur == N: <span class="comment">#边界条件到N的时候需要输出结果</span></span><br><span class="line">        <span class="built_in">print</span>(A[:N])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>): <span class="comment">#遍历所有的情况</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> V[i]: <span class="comment">#V为标志，到排序的这个位置上没有数据时候，进入下一步</span></span><br><span class="line">                V[i] = <span class="literal">True</span> <span class="comment">#首先改变标志位为true，输入需要排入的数值</span></span><br><span class="line">                A[cur] = i</span><br><span class="line">                dfs(cur+<span class="number">1</span>) <span class="comment">#继续往下搜索</span></span><br><span class="line">                V[i] = <span class="literal">False</span> <span class="comment">#跳出了循环，需要回溯到进入循环之前的状态</span></span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>问题: 数字1~n围成一个n个节点的环, 不允许数字重复, 任意2个相邻数字相加, 结果均为素数, 打印所有素数环的组合.<br>思路: 同排列数, 多了素数判断. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)]</span><br><span class="line">N = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n%i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur</span>):</span><br><span class="line">    <span class="keyword">if</span> cur == N:</span><br><span class="line">        <span class="keyword">if</span> is_prime(A[<span class="number">0</span>]+A[N-<span class="number">1</span>]):</span><br><span class="line">            <span class="built_in">print</span>(A[:N])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> A[:cur]:</span><br><span class="line">                <span class="keyword">if</span> cur == <span class="number">0</span> <span class="keyword">or</span> is_prime(i+A[cur-<span class="number">1</span>]):</span><br><span class="line">                    A[cur] = i</span><br><span class="line">                    dfs(cur+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A = [<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)]</span><br><span class="line">V = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)]</span><br><span class="line">N = <span class="number">6</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n//<span class="number">2</span>+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n%i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cur</span>):</span><br><span class="line">    <span class="keyword">if</span> cur == N:</span><br><span class="line">        <span class="keyword">if</span> is_prime(A[<span class="number">0</span>]+A[N-<span class="number">1</span>]):</span><br><span class="line">            <span class="built_in">print</span>(A[:N])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> V[i]:</span><br><span class="line">                <span class="keyword">if</span> cur == <span class="number">0</span> <span class="keyword">or</span> is_prime(i+A[cur-<span class="number">1</span>]):</span><br><span class="line">                    V[i] = <span class="literal">True</span></span><br><span class="line">                    A[cur] = i</span><br><span class="line">                    dfs(cur+<span class="number">1</span>)</span><br><span class="line">                    V[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
        <category>dfs</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法集合</title>
    <url>/hexoblog/2017/08/12/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p><strong><code>冒泡算法：</code></strong><br>比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。<br>针对所有的元素重复以上的步骤，除了最后一个。<br>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。<br>可以利用冒泡算法的案例：<br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，<br>所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。<br>遇到偶数在前奇数在后的情况交换两者的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble</span>(<span class="params">num,n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-i-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> num[j]&gt;num[j+<span class="number">1</span>]:</span><br><span class="line">                tmp=num[j]</span><br><span class="line">                num[j]=num[j+<span class="number">1</span>]</span><br><span class="line">                num[j+<span class="number">1</span>]=tmp</span><br><span class="line">    <span class="keyword">return</span> (num)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>选择算法：</code></strong><br>每次讲min置成无序组起始位置元素下标<br>例遍无序组找到最小的<br>如果最小元素不是无序组起始位置元素，则与起始元素交换位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">selectsort</span>(<span class="params">num,n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="built_in">min</span>=i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">            <span class="keyword">if</span> num[j]&lt;num[<span class="built_in">min</span>]:</span><br><span class="line">                <span class="built_in">min</span>=j</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">min</span>!=i:</span><br><span class="line">            tmp=num[i]</span><br><span class="line">            num[i]=num[<span class="built_in">min</span>]</span><br><span class="line">            num[<span class="built_in">min</span>]=tmp</span><br><span class="line">    <span class="keyword">return</span> (num)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>插入算法：</code></strong><br>插入排序原理很简单，讲一组数据分成两组，我分别将其称为有序组与待插入组。<br>每次从待插入组中取出一个元素，与有序组的元素进行比较，并找到合适的位置，将该元素插到有序组当中。<br>就这样，每次插入一个元素，有序组增加，待插入组减少。直到待插入组元素个数为0。<br>当然，插入过程中涉及到了元素的移动。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertsort</span>(<span class="params">num,n</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">        tmp=num[i]</span><br><span class="line">        j=i-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> tmp&lt;num[j]:</span><br><span class="line">            num[j+<span class="number">1</span>]=num[j]</span><br><span class="line">            j -=<span class="number">1</span></span><br><span class="line">        num[j+<span class="number">1</span>]=tmp</span><br><span class="line">    <span class="keyword">return</span> (num)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><code>快速排序：</code></strong><br>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，<br>然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br>一趟快速排序的算法是：<br> 1）设置两个变量i、j，排序开始的时候：i&#x3D;0，j&#x3D;N-1；<br> 2）以第一个数组元素作为关键数据，赋值给key，即key&#x3D;A[0]；<br> 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br> 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br> 5）重复第3、4步，直到i&#x3D;j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,4中A[i]不大于key的时候改变j、i的值，<br>使得j&#x3D;j-1，i&#x3D;i+1，直至找到为止。找到符合条件的值，进行交换的时候i， j指针位置不变。<br>另外，i&#x3D;&#x3D;j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">L, low, high</span>):</span><br><span class="line">    i = low </span><br><span class="line">    j = high</span><br><span class="line">    <span class="keyword">if</span> i &gt;= j:</span><br><span class="line">        <span class="keyword">return</span> L</span><br><span class="line">    key = L[i]</span><br><span class="line">    <span class="keyword">while</span> i &lt; j:</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> L[j] &gt;= key:</span><br><span class="line">            j = j-<span class="number">1</span>                                                             </span><br><span class="line">        L[i] = L[j]</span><br><span class="line">        <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> L[i] &lt;= key:    </span><br><span class="line">            i = i+<span class="number">1</span> </span><br><span class="line">        L[j] = L[i]</span><br><span class="line">    L[i] = key </span><br><span class="line">    quicksort(L, low, i-<span class="number">1</span>)</span><br><span class="line">    quicksort(L, j+<span class="number">1</span>, high)</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    num=[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(bubble(num,<span class="number">10</span>))</span><br><span class="line">    <span class="built_in">print</span>(selectsort(num,<span class="number">10</span>))</span><br><span class="line">    <span class="built_in">print</span>(insertsort(num,<span class="number">10</span>))</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
        <category>sort</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>模块-文件管理</title>
    <url>/hexoblog/2017/09/28/%E6%A8%A1%E5%9D%97-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><code>文件打开方式：</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(name，[mode[buf]])</span><br></pre></td></tr></table></figure>
<ul>
<li>name:文件路径</li>
<li>mode:打开方式，w：只写方式，文件不存在则创建文件，文件存在则清空文件不同于a追加模式。</li>
<li>buf:文件缓冲大小</li>
<li>r   只读方式打开</li>
<li>w  只写方式打开</li>
<li>a  追加方式打开</li>
<li>r+&#x2F;w+  读写方式打开</li>
<li>a+  追加和读写方式打开</li>
<li>…b二进制方式打开，例如处理图片信息，省略号表示前面的内容</li>
</ul>
<p><code>读取方式：</code></p>
<ul>
<li>read([size])读取文件，读取size个字节，默认读取全部</li>
<li>readline([size]):读取一行</li>
<li>readlnes([size]):读取完文件，返回每一行所组成的列表</li>
<li>readlines(1)能读取8192个字符数据，读取缓冲buff左右个字节</li>
<li>iter：使用迭代器读取文件，使用迭代器可以实现不消耗大量内存的情况下实现对文件的读取。iter(f)，然后利用for循环读取文件信息。</li>
</ul>
<p><code>写入操作：</code></p>
<ul>
<li>write(str)：写入字符串，写缓存机制，调用close、flush之后才会真正写入</li>
<li>writelines(sequence_of_strings)：写多行到文件<br>Linux缓存取大下可以通过write命令测试出来155648字节</li>
</ul>
<p><code>Python文件需要关闭:</code></p>
<ul>
<li>1.将写缓存同步到磁盘</li>
<li>2.linux系统中每个进程打开文件的个数是有限的</li>
<li>3.如果打开文件数到了系统限制，在打开文件就会失败</li>
</ul>
<p><code>Python文件指针操作：</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seek(offset[,whence]):</span><br></pre></td></tr></table></figure>
<p>移动文件指针；</p>
<ul>
<li><p>offset:偏移量，可以为负数</p>
</li>
<li><p>whence：偏移相对位置（SET、CUR、END）<br><code>import os</code></p>
</li>
<li><p>os.SEEK_SET:相对文件起始位置</p>
</li>
<li><p>os.SEEK_CUR:相对文件当前位置</p>
</li>
<li><p>os.SEEK_END:相对文件结尾位置</p>
</li>
</ul>
<p><code>Python文件属性:</code></p>
<ul>
<li>file.fileno():文件描述符</li>
<li>file.mode():文件打开权限</li>
<li>file.encoding():文件编码格式</li>
</ul>
<p><code>标准文件：</code><br>import sys模块</p>
<ul>
<li>文件标准输入：sys.stdin</li>
<li>文件标准输出：sys.stdout</li>
<li>文件标准错误：sys.stderr<br>文件命令行参数：<br>sys模块体改sys.argv属性，sys.argv是个字符串组成的列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">open</span>(fname,mode,encoding,..,..)</span><br></pre></td></tr></table></figure>
<p>打开文件可以指定编码方式utf-8格式可以识别中文字符</p>
<p><code>Python文件处理:</code><br>import os<br><code>使用os模块</code></p>
<ul>
<li>os.open</li>
<li>os.read</li>
<li>os.write</li>
<li>os.lseek</li>
<li>os.access 判断文件的权限：R_OK.W_OK.X_OK</li>
<li>listdir(path)返回当前目录下所有文件组成的列表</li>
<li>remove(path)删除文件</li>
<li>rename(old,new)修改文件或者目录名</li>
<li>mkdir(path[,mode])创建目录</li>
<li>mkdirs(path[,mode])创建多级目录</li>
<li>removedirs(path)删除多级目录</li>
<li>rmdir(path)删除目录（目录必须为空目录）</li>
<li>os.path.exits(path)当前路径是否存在<ul>
<li>.isdir(s)是否是一个目录</li>
<li>.isfile(path)是否是一个文件</li>
<li>.getsize(filename)返回文件大小</li>
<li>.dirname(p)返回路径的目录</li>
<li>.basename(p)返回路径的文件名</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器</title>
    <url>/hexoblog/2017/10/19/%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/27/59f2f571a094f.jpg" alt="mahua"></p>
<span id="more"></span>
<p>[生成器介绍文档](&lt;<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138681965108490cb4c13182e472f8d87830f13be6e88000">https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/00138681965108490cb4c13182e472f8d87830f13be6e88000</a>)<br><a href="http://python.jobbole.com/81911/">深入理解Python中的生成器</a></p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：<br>generator保存的是算法，每次调用next()，就计算出下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。当然，上面这种不断调用next()方法实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">     <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317799226173f45ce40636141b6abc8424e12b5fb27000">文档参考资料</a></p>
<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator，如将以下代码中得print改为yield即为生成器函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line">    a, b = b, a + b</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br></pre></td></tr></table></figure>

<p>generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。<br>由于yield的特性，于是我们利用for循环来输出生成器的所有元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span>(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fib(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

<p>返回值：</p>
<ul>
<li>在一个生成器中，遇到yeild则会输出yeild后面的参数，如果没有return，则默认执行到函数完毕时返回StopIteration；</li>
<li>如果遇到return,如果在执行过程中 return，则直接抛出 StopIteration 终止迭代。</li>
<li>如果在return后返回一个值，那么这个值为StopIteration异常的说明，不是程序的返回值。生成器没有办法使用return来返回值。</li>
</ul>
<p>总结：</p>
<ul>
<li>按照鸭子模型理论，生成器就是一种迭代器，可以使用for进行迭代。</li>
<li>第一次执行next(generator)时，会执行完yield语句后程序进行挂起，所有的参数和状态会进行保存。再一次执行next(generator)时，会从挂起的状态开始往后执行。在遇到程序的结尾或者遇到StopIteration时，循环结束。</li>
<li>可以通过generator.send(arg)来传入参数，生成器函数最大的特点是可以接受外部传入的一个变量，并根据变量内容计算结果后返回。这是协程模型。</li>
<li>可以通过generator.throw(exception)来传入一个异常。throw语句会消耗掉一个yield。用来向生成器函数送入一个异常，可以结束系统定义的异常，或者自定义的异常。可以通过generator.close()来手动关闭生成器。</li>
<li>next()等价于send(None)</li>
</ul>
<hr>
<h2 id="杨辉三角输出："><a href="#杨辉三角输出：" class="headerlink" title="杨辉三角输出："></a>杨辉三角输出：</h2><p>其特性在于：可以通过将前一行的样辉三角的输出作为下一行的输入，从而得到新的一行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tri</span>(<span class="params">num</span>):</span><br><span class="line">    L = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="keyword">yield</span> L</span><br><span class="line">        L = [<span class="number">1</span>]+[L[i]+L[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]+[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> tri(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(t)</span><br></pre></td></tr></table></figure>

<p>对比没有生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">triangles</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    L = [<span class="number">1</span>]</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="built_in">print</span>(L)</span><br><span class="line">        L = [<span class="number">1</span>]+[L[i] + L[i+<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(L)-<span class="number">1</span>)]+[<span class="number">1</span>]<span class="comment">#1 2 3 1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">triangles(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>碎片2</title>
    <url>/hexoblog/2017/05/12/%E7%A2%8E%E7%89%872/</url>
    <content><![CDATA[<p>雪城云，微山雨，游鱼在水雁在云。 </p>
<p>遥遥绵雨寄情愫，此情深深悲千古。 </p>
<p>苍云甲，长歌琴，赤甲藏心琴藏影。 </p>
<p>坚坚盾护怜疏影，望尽纷纷天涯路。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>碎片</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>碎片1</title>
    <url>/hexoblog/2017/05/12/%E7%A2%8E%E7%89%871/</url>
    <content><![CDATA[<p>巷陌乍晴，絮飞草上，断线纸鸢醉春风。 </p>
<p>香径里少年寻觅，小楼上伊人望空。 </p>
<p>素月当空，烛影更阑，傻傻少年思悠悠。 </p>
<p>想着明儿把线断，借着由儿再寻楼。</p>
]]></content>
      <categories>
        <category>随笔</category>
        <category>碎片</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>碎片</tag>
      </tags>
  </entry>
  <entry>
    <title>test for hexoblog</title>
    <url>/hexoblog/2025/03/16/%E7%AC%94%E8%AE%B0-20250316-hexoblog/</url>
    <content><![CDATA[<p>#笔记</p>
<p>test for hexoblog</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>hexo</tag>
        <tag>npm</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器</title>
    <url>/hexoblog/2017/10/21/%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2017/10/27/59f2a591c7383.jpg" alt="mahua"></p>
<span id="more"></span>

<p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318435599930270c0381a3b44db991cd6d858064ac0000%3E">本文转载至廖雪峰装饰器资料</a><br>该文对装饰器的解释比较利于理解。<br>由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def now():</span><br><span class="line">...     <span class="keyword">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">f</span> = now</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">f</span>()</span><br><span class="line"><span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>函数对象有一个__name__属性，可以拿到函数的名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</span><br><span class="line"><span class="string">&#x27;now&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.__name__</span><br><span class="line"><span class="string">&#x27;now&#x27;</span></span><br></pre></td></tr></table></figure>

<p>现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p>
<p>本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">call now():</span><br><span class="line"><span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>把@log放到now()函数的定义处，相当于执行了语句：</p>
<p>now &#x3D; log(now)<br>由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。</p>
<p>wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用，支持一维数组*args以及二维数组**kw。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>
<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>

<p>这个3层嵌套的decorator用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@log(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2015-3-25&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now()</span><br><span class="line">execute now():</span><br><span class="line"><span class="number">2015</span>-<span class="number">3</span>-<span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>和两层嵌套的decorator相比，3层嵌套的效果是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = log(<span class="string">&#x27;execute&#x27;</span>)(now)</span><br></pre></td></tr></table></figure>

<p>我们来剖析上面的语句，首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。</p>
<p>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的’now’变成了’wrapper’，但是在装饰器函数当中，now.__name__是正常的，只有在经过乐装饰器函数之后，函数名字发生了变化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>now.__name__</span><br><span class="line"><span class="string">&#x27;wrapper&#x27;</span></span><br></pre></td></tr></table></figure>

<p>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</p>
<p>不需要编写wrapper.<strong>name</strong> &#x3D; func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>或者针对带参数的decorator：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>

<p>import functools是导入functools模块。模块的概念稍候讲解。现在，只需记住在定义wrapper()的前面加上@functools.wraps(func)即可。</p>
<p>小结</p>
<p>在面向对象（OOP）的设计模式中，decorator被称为装饰模式。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。<br>decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。</p>
<p>样例学习：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kw</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(text, <span class="string">&#x27;__call__&#x27;</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s():&#x27;</span> % (func.__name__))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))</span><br><span class="line">            func(*args, **kw)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;end\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(text, <span class="string">&#x27;__call__&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> decorator(text)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnow</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是不带参数的&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@log(<span class="params"><span class="string">&quot;I&#x27;m 参数。&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newnow2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;带了参数&#x27;</span>)   </span><br><span class="line"></span><br><span class="line">newnow()</span><br><span class="line"><span class="built_in">print</span>(newnow.__name__)</span><br><span class="line">newnow2()</span><br><span class="line"><span class="built_in">print</span>(newnow2.__name__)</span><br></pre></td></tr></table></figure>
<p>结果：<br>newnow():<br>这是不带参数的<br>end</p>
<p>I’m 参数。 newnow2():<br>带了参数<br>end</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法饭店招待问题</title>
    <url>/hexoblog/2017/09/14/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E9%A5%AD%E5%BA%97%E6%8B%9B%E5%BE%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>问题描述：<br>某餐馆有n张桌子，每张桌子有一个参数：a 可容纳的最大人数； 有m批客人，每批客人有两个参数:b人数，c预计消费金额。在不允许拼桌的情况下，请实现一个算法选择其中一部分客人，使得总预计消费金额最大</p>
<p>基本思路：<br>桌子序列升序排列，客人按照预定花钱多少降序排序，然后贪心法从钱多的客人开始招呼。在遍历能容得下第i批客人的时候需要二分查找去找否则超时。</p>
<p>输入：<br>3 5<br>2 4 2<br>1 3<br>3 5<br>3 7<br>5 9<br>1 10<br>输出：<br>20</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n,m=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> raw_input().split()]</span><br><span class="line">    a=[<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> raw_input().split()]</span><br><span class="line">    guest=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        guest.append([<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> raw_input().split()])</span><br><span class="line">    <span class="built_in">print</span>(func(n,m,a,guest))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">n,m,a,guest</span>):</span><br><span class="line">    a.sort()</span><br><span class="line">    value = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    guest.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; m:</span><br><span class="line">        index=search(a,guest[i][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> index&gt;<span class="number">0</span>:</span><br><span class="line">            j = j+<span class="number">1</span></span><br><span class="line">            value +=guest[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">del</span> a[index]</span><br><span class="line">            <span class="keyword">if</span> j == n:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        i=i+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">nums,target</span>):</span><br><span class="line">    <span class="keyword">if</span> target&lt;=nums[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> target&gt;nums[-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    l=<span class="number">0</span></span><br><span class="line">    r=<span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (l+<span class="number">1</span>)!=r:</span><br><span class="line">        mid=(l+r)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> target&lt;=nums[mid]:</span><br><span class="line">            r=mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l=mid</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>code</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>code</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
